# (4) Quota 설정-2

## 1. 배경

[(3) Quota 설정-1](https://www.notion.so/3-Quota-1-254e19595aec803c92d6da0a4cf0b53a?pvs=21)

앞선 Quota 설정에서는 고정된 값을 Quota로 설정하였다. 

---

## 2. 개요

**(방안2) Profile 설정 :** 과목(프로젝트)에 미리 정한 프로파일(Basic/Lab)을 선택해 고정된 vCPU/RAM/Disk 상한을 한 번에 적용하는 방식.

**(방안3) 수업 단위 유동적 설정:** 학생수·학생당 VM·VM당 자원·헤드룸을 입력해 계산식으로 상한을 산출 및 적용

(방안2)을 Go Server를 도입하여 개발하고자 한다.

---

## 3. Go 서버 구축 실습

### 3-1. 아키텍처 개요

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image.png)

- Go → Keystone: “auth/token + catalog”
- Go → Nova: “PUT/GET /compute/v2.1/os-quota-sets/{project_id}”
- Go → Cinder: “PUT/GET /volume/v3/{admin_project_id}/os-quota-sets/{project_id}”

---

### 3-2. Go 서버 엔드포인트 설계

`POST /quota/applyProfile`

**Request Body**

```json
{ "projectId": "<대상 과목 프로젝트 ID>", "profile": "basic", "dryRun": false }
```

- `profile`" basic" 또는 "lab".
- `dryRun`=true면 계산/검증만 하고 실제 변경은 안 함.

**Response**

```json
{
  "plan": { "cores":8, "ramMB":16384, "instances":10, "gigabytes":100, "volumes":10, "snapshots":10 },
  "diff": { "nova": {...}, "cinder": {...} }, 
  "applied": true
}
```

- `plan`: 이번에 적용하려는 목표값.
- `diff`: 기존값 대비 변경점(검증·감사용).
- `applied`: 실제 반영 여부(dryRun이면 false).

- 메모 (내부 동작 / 실패 예외 처리 정책)
    
    # Go 서버 내부 동작(요청 1회 처리 플로우)
    
    1. **입력 검증**
        - `projectId` 존재/형식 체크.
        - `profile ∈ {basic, lab}` 확인.
    2. **프로파일 로드**
        - 서버 내 상수 테이블:
            - **basic**: vCPU=8, RAM=16384MB(16GiB), instances=10, gigabytes=100, volumes=10, snapshots=10
            - **lab**: vCPU=16, RAM=32768MB(32GiB), instances=20, gigabytes=200, volumes=20, snapshots=20
    3. **인증 & 엔드포인트 확정**
        - Keystone에 **스코프 토큰** 발급(또는 캐시된 토큰 재사용).
        - service catalog에서 **Nova/Cinder public URL** 확인.
        - 토큰 만료 시 자동 재발급(401 감지 → 재시도).
    4. **사전 점검(Preflight)**
        - **현재 쿼터 조회**
            - Nova: `GET /compute/v2.1/os-quota-sets/{project_id}`
            - Cinder: `GET /volume/v3/{admin_project_id}/os-quota-sets/{project_id}`
        - **사용량/상세 조회(선택)**
            - Nova: `GET .../detail` (in_use·limit 확인)
            - Cinder: `GET ...?usage=true`
        - **용량/정책 가드(선택)**
            - 하이퍼바이저 대략 용량: `GET /os-hypervisors/statistics`
            - 목표 limit가 현재 in_use보다 낮으면 실패 처리.
    5. **diff 계산**
        - 기존값 ↔ 프로파일 목표값 차이를 만들어 응답에 포함(감사/리뷰 용).
    6. **dryRun 처리**
        - `dryRun=true`면 여기서 종료(계산 결과만 반환).
    7. **실 적용(트랜잭션적 처리)**
        - Nova PUT → 성공 시 Cinder PUT.
        - **부분 실패 방지 전략**
            - 두 서비스 모두 사전 검증 성공 시에만 실행
            - 한쪽 실패 시, 가능하면 이미 변경된 쪽에 **롤백 PUT** 시도(백업값으로 복귀)
            - 실패를 응답에 명확히 기록
    8. **사후 검증(Post-apply)**
        - Nova/Cinder 각각 **재조회**로 목표값 반영 확인.
        - 결과(최종값/변경 내역) 응답.
    9. **감사 로그/백업(선택)**
        - 적용 전 쿼터 JSON을 파일/DB에 저장(종강 원복용).
        - 누가/언제/어떤 profile을 어느 project에 적용했는지 로깅.
    
    ---
    
    # 실패·예외 처리 정책
    
    - **401 Unauthorized**: 토큰 만료 → 재인증 후 1회 재시도.
    - **403 Forbidden**: 권한 부족(프로젝트/역할 확인 필요) → 에러 반환.
    - **400 Bad Request**: 경로·JSON·단위 오류 → 원인 메시지 그대로 응답.
    - **Cinder 경로 오류 방지**: 항상 `/{ADMIN_PROJECT_ID}/os-quota-sets/{TARGET_PROJECT_ID}` 사용.
    - **단위 주의**: Nova RAM은 **MB**, Cinder gigabytes는 **GB**.
    - **부분 성공**: Nova 성공·Cinder 실패 시, Nova를 백업값으로 즉시 복구 시도.

---

### 3-3. Go 서버 구축

**(0) 개요** 

mac mini, Sequoia v15.6, Cursor

**(1) 프로젝트 초기화**

```bash
mkdir -p ~/quota-api && cd ~/quota-api
go mod init example.com/quotaapi
```

**(2) 서버 기본 코드 작성** 

1. **/healthz**: 서버 상태 확인용 (GET 요청)
2. **/quota/applyProfile**: Quota Profile 적용(POST 요청) - 아직 미구현

```go
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
)

// 헬퍼: JSON 응답을 쓰는 함수
func writeJSON(w http.ResponseWriter, code int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	_ = json.NewEncoder(w).Encode(v)
}

// GET /healthz → 서버 살아있는지 확인용
func healthHandler(w http.ResponseWriter, r *http.Request) {
	writeJSON(w, http.StatusOK, map[string]any{"ok": true})
}

// POST /quota/applyProfile
type applyReq struct {
	ProjectID   string `json:"projectId"`
	Profile     string `json:"profile"`     // "basic" | "lab"
	DryRun      bool   `json:"dryRun"`      // 적용 미리보기
	IncludeDiff bool   `json:"includeDiff"` // 변경점 포함할지
}

func applyProfileHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		writeJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "POST only"})
		return
	}
	var req applyReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "bad json: " + err.Error()})
		return
	}
	// 아직 구현 전: 입력 에코 + Not Implemented 표시
	writeJSON(w, http.StatusNotImplemented, map[string]any{
		"received": req,
		"message":  "applyProfile not implemented yet",
	})
}

func main() {
	http.HandleFunc("/healthz", healthHandler)
	http.HandleFunc("/quota/applyProfile", applyProfileHandler)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	log.Println("listening on :" + port)
	log.Fatal(http.ListenAndServe(":"+port, nil))
}

```

- 주요 코드 설명
    
    ```go
    func applyProfileHandler(w http.ResponseWriter, r *http.Request) {
    	// r.Method로 요청의 HTTP 메서드를 확인
    	// POST가 아니면 "405 Method Not Allowed" 에러 반환
    	// return으로 함수 종료
    	if r.Method != http.MethodPost {
    		writeJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "POST only"})
    		return
    	}
    
    	// 	req 변수를 applyReq 타입으로 선언
    	// r.Body에서 JSON 데이터를 읽어서 req 구조체에 파싱
    	// 파싱 실패시 "400 Bad Request" 에러 반환
    	var req applyReq
    	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "bad json: " + err.Error()})
    		return
    	}
    
    	// 아직 구현 전: 입력 에코 + Not Implemented 표시
    	writeJSON(w, http.StatusNotImplemented, map[string]any{
    		"received": req,
    		"message":  "applyProfile not implemented yet",
    	})
    }
    ```
    

**(3) 실행 확인**

```bash
 go run . #서버 실행
```

```bash
# 다른 터미널에서 수행
curl -s http://127.0.0.1:8080/healthz | jq .

curl -s -X POST http://127.0.0.1:8080/quota/applyProfile \
  -H 'content-type: application/json' \
  -d '{"projectId":"demo","profile":"basic","dryRun":true,"includeDiff":true}' | jq .
```

- 실행 결과
    
    API 요청에 적합한 응답이 온 것을 확인할 수 있다. 
    
    ![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%201.png)
    

---

### 3-4. 프로파일 정의 및 검증

**(1) 프로파일 코드 작성** 

```go
# 프로파일 정의
var profiles = map[string]plan{
	"basic": {Cores: 8, RAMMB: 16384, Instances: 10, Gigabytes: 100, Volumes: 10, Snapshots: 10},
	"lab":   {Cores: 16, RAMMB: 32768, Instances: 20, Gigabytes: 200, Volumes: 20, Snapshots: 20},
}
```

```go
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"strings"
)

// 추가 
// plan: 프로파일에 따른 목표 쿼터 값
type plan struct {
	Cores     int `json:"cores"`     // vCPU
	RAMMB     int `json:"ramMB"`     // RAM in MB
	Instances int `json:"instances"` // 인스턴스 수
	Gigabytes int `json:"gigabytes"` // Cinder 디스크 총량(GB)
	Volumes   int `json:"volumes"`
	Snapshots int `json:"snapshots"`
}

// 추가 
// 프로파일별 쿼터 설정
var profiles = map[string]plan{
	"basic": {Cores: 8, RAMMB: 16384, Instances: 10, Gigabytes: 100, Volumes: 10, Snapshots: 10},
	"lab":   {Cores: 16, RAMMB: 32768, Instances: 20, Gigabytes: 200, Volumes: 20, Snapshots: 20},
}

type applyReq struct {
	ProjectID   string `json:"projectId"`
	Profile     string `json:"profile"`     // "basic" | "lab"
	DryRun      bool   `json:"dryRun"`      // 적용 미리보기
	IncludeDiff bool   `json:"includeDiff"` // 변경점 포함할지
}

// JSON 응답 헬퍼 함수
func writeJSON(w http.ResponseWriter, code int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	_ = json.NewEncoder(w).Encode(v)
}

// GET /healthz → 서버 상태 확인
func healthHandler(w http.ResponseWriter, r *http.Request) {
	writeJSON(w, http.StatusOK, map[string]any{"ok": true})
}

func applyProfileHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		writeJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "POST only"})
		return
	}
	var req applyReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "bad json: " + err.Error()})
		return
	}

	// 프로젝트 ID 검증
	if strings.TrimSpace(req.ProjectID) == "" {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "projectId is required"})
		return
	}
	
	// 추가 
	// 프로파일 검증 및 plan 가져오기
	p, ok := profiles[strings.ToLower(req.Profile)]
	if !ok {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "unknown profile (use 'basic' or 'lab')"})
		return
	}

	// 추가 
	// plan 반환 (실제 적용은 다음 단계)
	resp := map[string]any{
		"plan":      p,          // 목표 쿼터 값
		"applied":   false,      // 아직 적용 안 함
		"dryRun":    req.DryRun, // 요청값 그대로 표시
		"message":   "plan computed. Next step: fetch current quotas & diff, then apply.",
		"projectId": req.ProjectID,
		"profile":   strings.ToLower(req.Profile),
	}
	writeJSON(w, http.StatusOK, resp)
}

func main() {
	http.HandleFunc("/healthz", healthHandler)
	http.HandleFunc("/quota/applyProfile", applyProfileHandler)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	log.Println("listening on :" + port)
	log.Fatal(http.ListenAndServe(":"+port, nil))
}

```

**(2) 실행 확인** 

```bash
go run .
```

```bash
# 다른 터미널에서 API 요청

#(1) profile: basic
curl -s -X POST http://127.0.0.1:8080/quota/applyProfile \
  -H 'content-type: application/json' \
  -d '{"projectId":"demo","profile":"basic","dryRun":true,"includeDiff":true}' | jq .

#(2) profile: lab
curl -s -X POST http://127.0.0.1:8080/quota/applyProfile \
  -H 'content-type: application/json' \
  -d '{"projectId":"demo","profile":"lab","dryRun":true,"includeDiff":true}' | jq .

#(3) profile: non-profile
curl -s -X POST http://127.0.0.1:8080/quota/applyProfile \
  -H 'content-type: application/json' \
  -d '{"projectId":"demo","profile":"non-profile","dryRun":true,"includeDiff":true}' | jq .
```

**(3) 실행 결과**

![Screenshot 2025-08-20 at 11.35.14 AM.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/Screenshot_2025-08-20_at_11.35.14_AM.png)

- request 내 profile에 따라 매핑이 되는 것을 확인할 수 있다.

---

## 4. Openstack 서비스 연동

### 4-1. Keystone 인증

현재 Go Server 내 API 작동만 확인되었다. **Openstack 내 Keystone, nova, cinder와 연결이 필요하다.**

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%202.png)

**(1) 디렉토리 구조 설정** 

```markdown
quota-api/
├─ cmd/server/              ← 실행 엔트리(바이너리 생성 지점)
├─ internal/                ← 앱의 내부 구현(캡슐화)
│  ├─ config/               ← 환경변수 로딩/검증
│  ├─ http/                 ← HTTP 핸들러(요청/응답만 담당)
│  └─ openstack/            ← Keystone 등 외부(OpenStack) 연동
└─ go.mod                   ← Go 모듈 설정(의존성/모듈 경로)
```

**(1) gophercloud 설치**

```go
# 로컬 컴퓨터 내 터미널
# Go 모듈 의존성 설치 
go get github.com/gophercloud/gophercloud@latest
```

gophercloud는 Openstack 용 Go SDK로서, 각 서비스의 클라이언트, 타입, 헬퍼를 제공한다.

**(2) .env 환경변수 설정**

```bash
export OS_AUTH_URL=http://192.168.64.4/identity/v3
export OS_USERNAME=admin
export OS_PASSWORD=secret
export OS_USER_DOMAIN_ID=default
export OS_PROJECT_NAME=admin
export OS_REGION_NAME=RegionOne
```

**(3) 코드 작성**

![디렉토리 구조]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%203.png)

디렉토리 구조

```go
// auth.go
package openstack

import (
	"github.com/gophercloud/gophercloud"
	"github.com/gophercloud/gophercloud/openstack"

	"example.com/quotaapi/internal/config"
)

// Keystone 로그인: Provider(토큰 보관) + Identity v3 클라이언트 생성
func NewIdentity(c *config.Config) (*gophercloud.ProviderClient, *gophercloud.ServiceClient, error) {
	ao := gophercloud.AuthOptions{
		IdentityEndpoint: c.AuthURL,
		Username:         c.Username,
		Password:         c.Password,
		DomainID:         c.UserDomainID,
		TenantName:       c.ProjectName, // 프로젝트 스코프
		AllowReauth:      true,
	}
	provider, err := openstack.AuthenticatedClient(ao)
	if err != nil {
		return nil, nil, err
	}
	ident, err := openstack.NewIdentityV3(provider, gophercloud.EndpointOpts{
		Region: c.RegionName,
	})
	if err != nil {
		return nil, nil, err
	}
	return provider, ident, nil
}

// 토큰 조회(X-Subject-Token). subjectToken이 비었으면 서비스 토큰 자체 조회.
func IntrospectToken(ident *gophercloud.ServiceClient, provider *gophercloud.ProviderClient, subjectToken string) (map[string]any, error) {
	if subjectToken == "" {
		subjectToken = provider.TokenID
	}
	var raw map[string]any
	_, err := ident.Get(
		ident.ServiceURL("auth", "tokens"),
		&raw,
		&gophercloud.RequestOpts{
			MoreHeaders: map[string]string{
				"X-Subject-Token": subjectToken,
			},
		},
	)
	return raw, err
}

```

```go
// auth_handler.go
package http

import (
	"encoding/json"
	"log"
	"net/http"

	"example.com/quotaapi/internal/config"
	osauth "example.com/quotaapi/internal/openstack"
)

// 공통 JSON 응답
func WriteJSON(w http.ResponseWriter, code int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	_ = json.NewEncoder(w).Encode(v)
}

// GET /auth/check
// - 헤더 X-Auth-Token 이 있으면 그 토큰을 검증
// - 없으면 서비스 토큰(환경변수 계정으로 발급된 토큰)을 검증
func NewAuthCheckHandler(cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodGet {
			WriteJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "GET only"})
			return
		}
		provider, ident, err := osauth.NewIdentity(cfg)
		if err != nil {
			WriteJSON(w, http.StatusBadGateway, map[string]string{"error": "keystone auth error: " + err.Error()})
			return
		}
		subject := r.Header.Get("X-Auth-Token")
		raw, err := osauth.IntrospectToken(ident, provider, subject)
		if err != nil {
			WriteJSON(w, http.StatusBadGateway, map[string]string{"error": "token introspection failed: " + err.Error()})
			return
		}

		// 안전 캐스팅
		token, _ := raw["token"].(map[string]any)
		user, _ := token["user"].(map[string]any)
		project, _ := token["project"].(map[string]any)
		roles, _ := token["roles"].([]any)
		log.Println(raw["token"])

		WriteJSON(w, http.StatusOK, map[string]any{
			"auth": "ok",
			"user": map[string]any{
				"id":     safe(user, "id"),
				"name":   safe(user, "name"),
				"domain": user["domain"],
			},
			"project": map[string]any{
				"id":     safe(project, "id"),
				"name":   safe(project, "name"),
				"domain": project["domain"],
			},
			"token": map[string]any{
				"issued_at":  safe(token, "issued_at"),
				"expires_at": safe(token, "expires_at"),
			},
			"roles": roles, // [{id,name}, ...]
		})
	}
}

func safe(m map[string]any, k string) any {
	if m == nil {
		return ""
	}
	if v, ok := m[k]; ok && v != nil {
		return v
	}
	return ""
}

```

```go
package config

import (
	"errors"
	"os"

	"github.com/joho/godotenv"
)

type Config struct {
	AuthURL      string // OS_AUTH_URL
	Username     string // OS_USERNAME
	Password     string // OS_PASSWORD
	UserDomainID string // OS_USER_DOMAIN_ID
	ProjectName  string // OS_PROJECT_NAME
	RegionName   string // OS_REGION_NAME
}

func Load() (*Config, error) {
	_ = godotenv.Load(".env")

	c := &Config{
		AuthURL:      os.Getenv("OS_AUTH_URL"),
		Username:     os.Getenv("OS_USERNAME"),
		Password:     os.Getenv("OS_PASSWORD"),
		UserDomainID: os.Getenv("OS_USER_DOMAIN_ID"),
		ProjectName:  os.Getenv("OS_PROJECT_NAME"),
		RegionName:   os.Getenv("OS_REGION_NAME"),
	}
	if c.AuthURL == "" || c.Username == "" || c.Password == "" ||
		c.UserDomainID == "" || c.ProjectName == "" || c.RegionName == "" {
		return nil, errors.New("missing one or more OpenStack envs: OS_AUTH_URL, OS_USERNAME, OS_PASSWORD, OS_USER_DOMAIN_ID, OS_PROJECT_NAME, OS_REGION_NAME")
	}
	return c, nil
}

```

**(4) 실행 확인**

```go
// main.go가 위치한 server directory에서 진행 
go run .
```

```go
curl -sS "http://localhost:8080/healthz" | jq .

curl -sS "http://localhost:8080/auth/check" | jq .
```

- 실행 결과
    
    ![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%204.png)
    
    ```json
    // curl -sS "http://localhost:8080/auth/check" | jq .
    {
      "auth": "ok",
      "project": {
        "domain": {
          "id": "default",
          "name": "Default"
        },
        "id": "144ba567a5db4334bce43a8c3b54f710",
        "name": "admin"
      },
      "roles": [
        {
          "id": "4a7a581ed3944bd1a85d3ff08c5fffb9",
          "name": "reader"
        },
        {
          "id": "a0c9ac9d7f37465d9b779348d4c95019",
          "name": "manager"
        },
        {
          "id": "183833c139524b829a28e9cfde689d1d",
          "name": "member"
        },
        {
          "id": "fe38aced0ab04ca3866a79ec1b1edd45",
          "name": "admin"
        }
      ],
      "token": {
        "expires_at": "2025-08-27T00:30:10.000000Z",
        "issued_at": "2025-08-26T23:30:10.000000Z"
      },
      "user": {
        "domain": {
          "id": "default",
          "name": "Default"
        },
        "id": "0eead67f8a7b4336a730d213ab37bb0b",
        "name": "admin"
      }
    }
    ```
    

**(5) OpenStack Client**

Keystone 인증을 거친 후 만들어지는 **provider, ident** 두가지 유형의 client가 존재한다. 

**(5-1) provider**

- `provider, err := openstack.AuthenticatedClient(ao)`
- OpenStack 전체 API 요청의 기반이 되는 인증된 클라이언트
- 다른 서비스 클라이언트(compute, network, identity, …)를 만들 때 공통 부모로 전달해야 하는 객체
- Keystone에 로그인해서 토큰과 카탈로그(엔드포인트 목록) 를 가져온다
- 세부 항목
    - Keystone이 발급한 Token
    - Token 만료 시간
    - 카탈로그(어떤 서비스가 있고, 어디에 접속해야 하는지)
    - Re-authentication 옵션
- provider (log)
    
    ```json
    {
      "token": {
        "audit_ids": ["KbahUf1oQ0CjCbsh8lFdcQ"],
        "catalog": [
          {
            "id": "1305ba8aa38546c38f5975f67b306f30",
            "name": "nova",
            "type": "compute",
            "endpoints": [
              {
                "id": "7746914cfce74837a2af01afdd8341ec",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/compute/v2.1"
              }
            ]
          },
          {
            "id": "1aec7f81009a4298bf7bdcab9d665c02",
            "name": "keystone",
            "type": "identity",
            "endpoints": [
              {
                "id": "1717dc020ae747a3a73c750a817da6c5",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/identity"
              }
            ]
          },
          {
            "id": "6bf73b34fca047809ccd93b7bb6bbb82",
            "name": "neutron",
            "type": "network",
            "endpoints": [
              {
                "id": "03bbbb933cfc44f884bb1050e9d9e1ed",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/networking"
              }
            ]
          },
          {
            "id": "7a09c659563b42968e271808e9284e56",
            "name": "cinder",
            "type": "block-storage",
            "endpoints": [
              {
                "id": "cbaac750652546f8947ebf4bb32b6895",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/volume/v3"
              }
            ]
          },
          {
            "id": "7cf962b57aa94bf19482221d73703600",
            "name": "glance",
            "type": "image",
            "endpoints": [
              {
                "id": "3faf8a7ee2af46ceb971f8d8121ebad2",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/image"
              }
            ]
          },
          {
            "id": "c8302fde18bf48f28f9d899c3045e713",
            "name": "nova_legacy",
            "type": "compute_legacy",
            "endpoints": [
              {
                "id": "cd90f7cb90604db794aef48e29c4c52f",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/compute/v2/144ba567a5db4334bce43a8c3b54f710"
              }
            ]
          },
          {
            "id": "efa2258cedae43dc82c3ce37ad0096f1",
            "name": "placement",
            "type": "placement",
            "endpoints": [
              {
                "id": "be853be6e35c4713bddd68d64c2f5a63",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/placement"
              }
            ]
          }
        ],
        "expires_at": "2025-08-27T00:44:48.000000Z",
        "issued_at": "2025-08-26T23:44:48.000000Z",
        "is_domain": false,
        "methods": ["password"],
        "project": {
          "id": "144ba567a5db4334bce43a8c3b54f710",
          "name": "admin",
          "domain": {
            "id": "default",
            "name": "Default"
          }
        },
        "roles": [
          { "id": "4a7a581ed3944bd1a85d3ff08c5fffb9", "name": "reader" },
          { "id": "a0c9ac9d7f37465d9b779348d4c95019", "name": "manager" },
          { "id": "183833c139524b829a28e9cfde689d1d", "name": "member" },
          { "id": "fe38aced0ab04ca3866a79ec1b1edd45", "name": "admin" }
        ],
        "user": {
          "id": "0eead67f8a7b4336a730d213ab37bb0b",
          "name": "admin",
          "domain": {
            "id": "default",
            "name": "Default"
          },
          "password_expires_at": null
        }
      }
    }
    
    ```
    

**(5-2) ident**

- `ident, err := openstack.NewIdentityV3(**provider**, gophercloud.EndpointOpts`
- 특정 OpenStack 서비스(해당 코드의 경우 keystone)에 연결하기 위한 서비스 클라이언트
- provider 가 가진 토큰과 카탈로그를 사용해 Identity API 요청 전용 클라이언트를 만든다
- /v3/users, /v3/projects, /v3/roles 같은 Identity API 엔드포인트를 호출할 때 사용

**(5-3) Openstack service client**

OpenStack은 Nova(Compute), Neutron(Network), Cinder(Block Storage), Glance(Image), Placement … 등 **서비스 단위**로 나뉘어 있다. 

→ 각 서비스에 접근하려면 **전용 ServiceClient를 생성**해야 한다. 

→ **provider를** 사용하여  ServiceClient를 생성한다

---

### 4-2. 쿼터 조회

**(1) gophercloud version 2로 변경**

```go
//루트 디렉토리에서 
go get github.com/gophercloud/gophercloud/v2@latest
go mod tidy
```

**(2) .env / config에 AdminProjectId 추가** 

- cinder API 호출을 위함
- `curl -sS "http://localhost:8080/auth/check" | jq .` 로 조회 가능

```go
package config

import (
	"errors"
	"os"

	"github.com/joho/godotenv"
)

type Config struct {
	AuthURL        string // OS_AUTH_URL
	Username       string // OS_USERNAME
	Password       string // OS_PASSWORD
	UserDomainID   string // OS_USER_DOMAIN_ID
	ProjectName    string // OS_PROJECT_NAME
	RegionName     string // OS_REGION_NAME
	AdminProjectID string // OS_ADMIN_PROJECT_ID // 추가
}

func Load() (*Config, error) {
	_ = godotenv.Load(".env")

	c := &Config{
		AuthURL:        os.Getenv("OS_AUTH_URL"),
		Username:       os.Getenv("OS_USERNAME"),
		Password:       os.Getenv("OS_PASSWORD"),
		UserDomainID:   os.Getenv("OS_USER_DOMAIN_ID"),
		ProjectName:    os.Getenv("OS_PROJECT_NAME"),
		RegionName:     os.Getenv("OS_REGION_NAME"),
		AdminProjectID: os.Getenv("OS_ADMIN_PROJECT_ID"), // 추가
	}
	if c.AuthURL == "" || c.Username == "" || c.Password == "" ||
		c.UserDomainID == "" || c.ProjectName == "" || c.RegionName == "" {
		return nil, errors.New("missing one or more OpenStack envs: OS_AUTH_URL, OS_USERNAME, OS_PASSWORD, OS_USER_DOMAIN_ID, OS_PROJECT_NAME, OS_REGION_NAME, OS_ADMIN_PROJECT_ID")
	}
	return c, nil
}

```

```go
OS_AUTH_URL=http://192.168.64.4/identity/v3
OS_USERNAME=admin
OS_PASSWORD=secret
OS_USER_DOMAIN_ID=default
OS_PROJECT_NAME=admin
OS_REGION_NAME=RegionOne
ADMIN_PROJECT_ID=144ba567a5db4334bce43a8c3b54f710 // 추가
```

**(3) Quota 조회 handler 추가**

```go
// quota_get_handler.go

package http

import (
	"net/http"

	osapi "example.com/quotaapi/internal/openstack"
)

type QuotaGetServer struct {
	OS *osapi.Clients
}

// GET /quota/current?projectId=xxxx
func (s *QuotaGetServer) Current(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		WriteJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "GET only"})
		return
	}

	projectID := r.URL.Query().Get("projectId")
	if projectID == "" {
		WriteJSON(w, http.StatusBadRequest, map[string]string{"error": "missing projectId"})
		return
	}

	nova, nErr := s.OS.GetNovaQuotaDetail(r.Context(), projectID)
	cind, cErr := s.OS.GetCinderQuotaDetail(r.Context(), projectID)
	if nErr != nil || cErr != nil {
		WriteJSON(w, http.StatusBadGateway, map[string]any{
			"error":  "quota read failed",
			"nova":   errString(nErr),
			"cinder": errString(cErr),
		})
		return
	}

	WriteJSON(w, http.StatusOK, map[string]any{
		"projectId": projectID,
		"nova":      nova,
		"cinder":    cind,
	})
}

func errString(err error) any {
	if err == nil {
		return nil
	}
	return err.Error()
}
```

```go
package main
// main.go에 추가

	qget := &httph.QuotaGetServer{OS: osc}
	http.HandleFunc("/quota/current", qget.Current)

```

**(4) Nova, Cinder service client 생성** 

```go
//clients.go
package openstack

import (
	"fmt"

	"example.com/quotaapi/internal/config"
	"github.com/gophercloud/gophercloud/v2"
	"github.com/gophercloud/gophercloud/v2/openstack"
)

type Clients struct {
	Provider       *gophercloud.ProviderClient
	Identity       *gophercloud.ServiceClient
	ComputeV2      *gophercloud.ServiceClient
	BlockStorageV3 *gophercloud.ServiceClient
	AdminProjectID string
	Region         string
}

func NewServiceClients(cfg *config.Config) (*Clients, error) {
	provider, ident, err := NewIdentity(cfg)
	if err != nil {
		return nil, fmt.Errorf("keystone auth: %w", err)
	}

	compute, err := openstack.NewComputeV2(provider, gophercloud.EndpointOpts{Region: cfg.RegionName})
	if err != nil {
		return nil, fmt.Errorf("new compute v2: %w", err)
	}

	block, err := openstack.NewBlockStorageV3(provider, gophercloud.EndpointOpts{
		Region:       cfg.RegionName,
		Type:         "block-storage",                // 카탈로그에 있는 type 과 맞춤
		Name:         "cinder",                       // (선택) name 일치시켜 매칭 더 확실
		Availability: gophercloud.AvailabilityPublic, // public endpoint 사용
	})
	if err != nil {
		return nil, fmt.Errorf("new blockstorage v3: %w", err)
	}

	return &Clients{
		Provider:       provider,
		Identity:       ident,
		ComputeV2:      compute,
		BlockStorageV3: block,
		AdminProjectID: cfg.AdminProjectID,
		Region:         cfg.RegionName,
	}, nil
}

```

**(5) Quota 정보 조회** 

> **nova GetDetail 메소드 정의**
> 
> 
> ```
> // GetDetail returns detailed public data about a previously created QuotaSet.
> func GetDetail(ctx context.Context, client *gophercloud.ServiceClient, tenantID string) (r GetDetailResult) {
> 	resp, err := client.Get(ctx, getDetailURL(client, tenantID), &r.Body, nil)
> 	_, r.Header, r.Err = gophercloud.ParseResponse(resp, err)
> 	return
> }
> ```
> 
> **cinder GetUsage 메소드 정의**
> 
> ```
> // GetUsage returns detailed public data about a previously created QuotaSet.
> func GetUsage(ctx context.Context, client *gophercloud.ServiceClient, projectID string) (r GetUsageResult) {
> 	u := fmt.Sprintf("%s?usage=true", getURL(client, projectID))
> 	resp, err := client.Get(ctx, u, &r.Body, nil)
> 	_, r.Header, r.Err = gophercloud.ParseResponse(resp, err)
> 	return
> }
> ```
> 

```go
// quotas_get.go
package openstack

import (
	"context"
	"fmt"

	cqs "github.com/gophercloud/gophercloud/v2/openstack/blockstorage/v3/quotasets"
	novaqs "github.com/gophercloud/gophercloud/v2/openstack/compute/v2/quotasets"
)

type QuotaDetail struct {
	Limit int `json:"limit"`
	InUse int `json:"in_use"`
}

type NovaQuotaDetail struct {
	Cores     QuotaDetail `json:"cores"`
	RAMMB     QuotaDetail `json:"ramMB"` // MB
	Instances QuotaDetail `json:"instances"`
}

type CinderQuotaDetail struct {
	Gigabytes QuotaDetail `json:"gigabytes"` // GB
	Volumes   QuotaDetail `json:"volumes"`
	Snapshots QuotaDetail `json:"snapshots"`
}

func (c *Clients) GetNovaQuotaDetail(ctx context.Context, projectID string) (*NovaQuotaDetail, error) {
	q, err := novaqs.GetDetail(ctx, c.ComputeV2, projectID).Extract()
	if err != nil {
		return nil, fmt.Errorf("nova get quota detail: %w", err)
	}
	return &NovaQuotaDetail{
		Cores:     QuotaDetail{Limit: q.Cores.Limit, InUse: q.Cores.InUse},
		RAMMB:     QuotaDetail{Limit: q.RAM.Limit, InUse: q.RAM.InUse},
		Instances: QuotaDetail{Limit: q.Instances.Limit, InUse: q.Instances.InUse},
	}, nil
}

func (c *Clients) GetCinderQuotaDetail(ctx context.Context, targetProjectID string) (*CinderQuotaDetail, error) {
	q, err := cqs.GetUsage(ctx, c.BlockStorageV3, targetProjectID).Extract()
	if err != nil {
		return nil, fmt.Errorf("cinder get quota detail: %w", err)
	}
	return &CinderQuotaDetail{
		Gigabytes: QuotaDetail{Limit: q.Gigabytes.Limit, InUse: q.Gigabytes.InUse},
		Volumes:   QuotaDetail{Limit: q.Volumes.Limit, InUse: q.Volumes.InUse},
		Snapshots: QuotaDetail{Limit: q.Snapshots.Limit, InUse: q.Snapshots.InUse},
	}, nil
}

```

- **Trouble Shooting: nova service type error**
    
    **(6) Trouble shooting** 🔥
    
    **서비스 타입**
    
    - 각 서비스는 Keystone에 **Service 객체**로 등록되고, 그 안에 `id`, `name`, `type` 이 있다
    - `type`은 Keystone 카탈로그 안에서 서비스(객체)를 식별하는 분류 키의 역할을 한다.
        - Nova → `compute`
        - Glance → `image`
        - Keystone → `identity`
        - Cinder → `block-storage` 혹은 `volumev3`
    
    **에러 메시지** 
    
    ```json
    ➜  server git:(main) ✗ go run .
    2025/08/27 17:06:48 new blockstorage v3: No suitable endpoint could be found in the service catalog.
    exit status 1
    ```
    
    **에러 원인** 
    
    ![provider log]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%205.png)
    
    provider log
    
    - provider를 확인해보면, cinder의 type이 `block-storage`인 것을 확인할 수 있다.(DevStack 권장 타입)
    - cinder 서비스의 type
        - 실제 카탈로그 → block-storage
        - gophercloud 기본 → volumev3
    
    **해결방법**
    
    cinder 객체를 찾을 수 있도록 endpoint 내부 type을 변경한다. 
    
    ```go
    block, err := openstack.NewBlockStorageV3(provider, gophercloud.EndpointOpts{
        Region:       cfg.RegionName,
        Type:         "block-storage",                // 카탈로그에 있는 type 과 맞춤
        Name:         "cinder",                       // (선택) name 일치시켜 매칭 더 확실
        Availability: gophercloud.AvailabilityPublic, // public endpoint 사용
    })
    ```
    

**(6) 실행 확인**

```bash
# projectId 확인
 curl -sS "http://localhost:8080/auth/check" | jq -r  '.project.id'
 
# projectId는 변경
curl -sS "http://localhost:8080/quota/current?projectId=144ba567a5db4334bce43a8c3b54f710" | jq .
```

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%206.png)

각 cinder, nova의 quota 값을 조회 할 수 있다. 

- Nova: `ramMB` → MB
- Cinder: `gigabytes` → GB

---

### 4-3. 쿼터 적용

**(0) 작업 배경** 

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%207.png)

keystone에서 provider를 발급받아, nova와 cinder service client를 생성하였다. 각 service client로 quota 조회 메소드 (GetDetail, GetUsage)를 호출하는 것까지 구현된 것이다.

![프로젝트 디렉토리 구조]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%208.png)

프로젝트 디렉토리 구조

**(1) 쿼터 적용 Request**

```
// types.go
package api

type ApplyQuotaRequest struct {
	ProjectID string `json:"projectId"`

	Nova *struct {
		Cores     *int `json:"cores"`
		RAMMB     *int `json:"ramMB"`
		Instances *int `json:"instances"`
	} `json:"nova,omitempty"`

	Cinder *struct {
		Volumes   *int `json:"volumes"`
		Snapshots *int `json:"snapshots"`
		Gigabytes *int `json:"gigabytes"`
	} `json:"cinder,omitempty"`
}

```

**(2) Handler 생성**

```go
// quotas_apply_handler.go
package http

import (
	"encoding/json"
	"net/http"

	"example.com/quotaapi/internal/api"
	"example.com/quotaapi/internal/openstack"
)

type QuotaApplyServer struct {
	OS *openstack.Clients
}

func (s *QuotaApplyServer) QuotaApply(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req api.ApplyQuotaRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "invalid JSON body", http.StatusBadRequest)
		return
	}
	if req.ProjectID == "" {
		http.Error(w, "missing projectId", http.StatusBadRequest)
		return
	}

	// 1) Nova 적용 (존재하는 항목만)
	if req.Nova != nil {
		if req.Nova.Cores == nil && req.Nova.RAMMB == nil && req.Nova.Instances == nil {
			// 아무 필드도 없으면 스킵
		} else {
			if err := s.OS.ApplyNovaQuota(ctx, req.ProjectID, req.Nova.Cores, req.Nova.RAMMB, req.Nova.Instances); err != nil {
				http.Error(w, err.Error(), http.StatusBadGateway)
				return
			}
		}
	}

	// 2) Cinder 적용
	if req.Cinder != nil {
		if req.Cinder.Volumes == nil && req.Cinder.Snapshots == nil && req.Cinder.Gigabytes == nil {
			// 아무것도 없으면 스킵
		} else {
			if err := s.OS.ApplyCinderQuota(ctx, req.ProjectID, req.Cinder.Volumes, req.Cinder.Snapshots, req.Cinder.Gigabytes); err != nil {
				http.Error(w, err.Error(), http.StatusBadGateway)
				return
			}
		}
	}

	// 3) 적용 후 최신 상태를 응답으로 돌려주면 UX가 좋음
	nova, _ := s.OS.GetNovaQuotaDetail(ctx, req.ProjectID)
	cinder, _ := s.OS.GetCinderQuotaDetail(ctx, req.ProjectID)

	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	_ = json.NewEncoder(w).Encode(map[string]any{
		"projectId": req.ProjectID,
		"nova":      nova,
		"cinder":    cinder,
		"status":    "applied",
	})
}

```

```go
package main
// main.go에 추가

	srv := &httph.QuotaApplyServer{OS: osc}
	http.HandleFunc("/quota/apply", srv.QuotaApply)

```

**(3) quotas_apply.go**

```go
//quotas_apply.go
package openstack

import (
	"context"
	"fmt"

	cqs "github.com/gophercloud/gophercloud/v2/openstack/blockstorage/v3/quotasets"
	novaqs "github.com/gophercloud/gophercloud/v2/openstack/compute/v2/quotasets"
)

func (c *Clients) ApplyNovaQuota(ctx context.Context, projectID string, cores, ramMB, instances *int) error {
	opts := novaqs.UpdateOpts{
		Cores:     cores,
		RAM:       ramMB,
		Instances: instances,
	}
	_, err := novaqs.Update(ctx, c.ComputeV2, projectID, opts).Extract()
	if err != nil {
		return fmt.Errorf("nova quota update: %w", err)
	}
	return nil
}

func (c *Clients) ApplyCinderQuota(ctx context.Context, projectID string, volumes, snapshots, gigabytes *int) error {
	opts := cqs.UpdateOpts{
		Volumes:   volumes,
		Snapshots: snapshots,
		Gigabytes: gigabytes,
	}

	_, err := cqs.Update(ctx, c.BlockStorageV3, projectID, opts).Extract()
	if err != nil {
		return fmt.Errorf("cinder quota update: %w", err)
	}
	return nil
}

```

**(4) 실행 확인** 

```bash
curl -sS -X POST http://localhost:8080/quota/apply \
  -H 'Content-Type: application/json' \
  -d '{
    "projectId":"144ba567a5db4334bce43a8c3b54f710",
    "nova":   {"cores": 20, "ramMB": 65536, "instances": 20},
    "cinder": {"volumes": 50, "snapshots": 20, "gigabytes": 1000}
  }' | jq .
```

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%209.png)

---

### 4-4. 프로파일 기반 쿼터 설정

- 앞서 3-4에서 진행한대로, `2가지 프로파일(basic, lab)`을 선택해 quota를 설정
- dryRun 옵션이 존재 → `dryRun=true`면 실제 쿼터 변경 없이 적용 계획만 시뮬레이션하여, 변경 사항을 미리 확인

> `/quota/applyProfile` 요청 플로우

1) 메서드/바디/필수 필드(projectId, profile) 검증
2) 프로파일 조회
3) 현재 쿼터 조회(Nova/Cinder)
4) includeDiff=true면 계획과 현재의 차이 계산
5) dryRun=false면 계획대로 Nova/Cinder 쿼터 적용 후 최신 상태 재조회
> 

**(1) handler 생성**

```go
package http

import (
	"encoding/json"
	"net/http"
	"strings"

	"example.com/quotaapi/internal/openstack"
)

// plan: 프로파일이 지정하는 목표 쿼터 값 집합
// - Nova: Cores, RAMMB, Instances
// - Cinder: Gigabytes, Volumes, Snapshots
// 실제 적용은 요청(dryRun=false)일 때 수행됨
type plan struct {
	Cores     int `json:"cores"`
	RAMMB     int `json:"ramMB"`
	Instances int `json:"instances"`
	Gigabytes int `json:"gigabytes"`
	Volumes   int `json:"volumes"`
	Snapshots int `json:"snapshots"`
}

// profiles: 사전에 정의된 프로파일 목록
// - 사용 예: profile=basic | lab
// - 필요한 경우 향후 설정 파일/DB로 분리 가능
var profiles = map[string]plan{
	"basic": {Cores: 8, RAMMB: 16384, Instances: 10, Gigabytes: 100, Volumes: 10, Snapshots: 10},
	"lab":   {Cores: 16, RAMMB: 32768, Instances: 20, Gigabytes: 200, Volumes: 20, Snapshots: 20},
}

// applyProfileReq: 프로파일 기반 쿼터 적용 요청 바디
// - dryRun=true  → 적용하지 않고 계획/차이만 반환
// - includeDiff → 현재 쿼터와의 차이값(diff) 포함 여부
type applyProfileReq struct {
	ProjectID   string `json:"projectId"`
	Profile     string `json:"profile"`
	DryRun      bool   `json:"dryRun"`
	IncludeDiff bool   `json:"includeDiff"`
}

// ApplyProfileServer: OpenStack 클라이언트를 주입받아 동작하는 핸들러 서버
type ApplyProfileServer struct {
	OS *openstack.Clients
}

// NewApplyProfileHandler: POST /quota/applyProfile 핸들러 생성
// - 요청을 검증하고 프로파일을 확인한 뒤
// - 현재 쿼터 조회, 필요 시 diff 계산, dryRun=false면 실제 적용
func NewApplyProfileHandler(os *openstack.Clients) http.HandlerFunc {
	s := &ApplyProfileServer{OS: os}
	return s.Handle
}

// Handle: /quota/applyProfile 처리 엔드포인트
// 요청 플로우
// 1) 메서드/바디/필수 필드(projectId, profile) 검증
// 2) 프로파일 조회
// 3) 현재 쿼터 조회(Nova/Cinder)
// 4) includeDiff=true면 계획과 현재의 차이 계산
// 5) dryRun=false면 계획대로 Nova/Cinder 쿼터 적용 후 최신 상태 재조회
func (s *ApplyProfileServer) Handle(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		WriteJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "POST only"})
		return
	}

	var req applyProfileReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		WriteJSON(w, http.StatusBadRequest, map[string]string{"error": "bad json: " + err.Error()})
		return
	}

	if strings.TrimSpace(req.ProjectID) == "" {
		WriteJSON(w, http.StatusBadRequest, map[string]string{"error": "projectId is required"})
		return
	}

	p, ok := profiles[strings.ToLower(req.Profile)]
	if !ok {
		WriteJSON(w, http.StatusBadRequest, map[string]string{"error": "unknown profile (use 'basic' or 'lab')"})
		return
	}

	ctx := r.Context()

	// 현재 쿼터 조회
	novaCurr, nErr := s.OS.GetNovaQuotaDetail(ctx, req.ProjectID)
	cinderCurr, cErr := s.OS.GetCinderQuotaDetail(ctx, req.ProjectID)
	if nErr != nil || cErr != nil {
		WriteJSON(w, http.StatusBadGateway, map[string]any{
			"error":  "failed to read current quotas",
			"nova":   errString(nErr),
			"cinder": errString(cErr),
		})
		return
	}

	// 기본 응답(계획/현재 상태)
	resp := map[string]any{
		"projectId": req.ProjectID,
		"profile":   strings.ToLower(req.Profile),
		"plan":      p,
		"applied":   false,
		"dryRun":    req.DryRun,
		"current": map[string]any{
			"nova": map[string]any{
				"cores":     novaCurr.Cores,
				"ramMB":     novaCurr.RAMMB,
				"instances": novaCurr.Instances,
			},
			"cinder": map[string]any{
				"gigabytes": cinderCurr.Gigabytes,
				"volumes":   cinderCurr.Volumes,
				"snapshots": cinderCurr.Snapshots,
			},
		},
	}

	// diff 포함 요청 시, 계획(limit)과 현재(limit)의 차이를 계산
	if req.IncludeDiff {
		resp["diff"] = map[string]any{
			"nova": map[string]int{
				"cores":     p.Cores - novaCurr.Cores.Limit,
				"ramMB":     p.RAMMB - novaCurr.RAMMB.Limit,
				"instances": p.Instances - novaCurr.Instances.Limit,
			},
			"cinder": map[string]int{
				"gigabytes": p.Gigabytes - cinderCurr.Gigabytes.Limit,
				"volumes":   p.Volumes - cinderCurr.Volumes.Limit,
				"snapshots": p.Snapshots - cinderCurr.Snapshots.Limit,
			},
		}
	}

	// 실제 적용(dryRun=false)
	if !req.DryRun {
		// Nova 쿼터 적용
		cores, ram, inst := p.Cores, p.RAMMB, p.Instances
		if err := s.OS.ApplyNovaQuota(ctx, req.ProjectID, &cores, &ram, &inst); err != nil {
			WriteJSON(w, http.StatusBadGateway, map[string]string{"error": "nova apply failed: " + err.Error()})
			return
		}

		// Cinder 쿼터 적용
		vols, snaps, gigs := p.Volumes, p.Snapshots, p.Gigabytes
		if err := s.OS.ApplyCinderQuota(ctx, req.ProjectID, &vols, &snaps, &gigs); err != nil {
			WriteJSON(w, http.StatusBadGateway, map[string]string{"error": "cinder apply failed: " + err.Error()})
			return
		}

		resp["applied"] = true

		// 적용 후 최신 상태 재조회
		novaCurr, _ = s.OS.GetNovaQuotaDetail(ctx, req.ProjectID)
		cinderCurr, _ = s.OS.GetCinderQuotaDetail(ctx, req.ProjectID)
		resp["current"] = map[string]any{
			"nova": map[string]any{
				"cores":     novaCurr.Cores,
				"ramMB":     novaCurr.RAMMB,
				"instances": novaCurr.Instances,
			},
			"cinder": map[string]any{
				"gigabytes": cinderCurr.Gigabytes,
				"volumes":   cinderCurr.Volumes,
				"snapshots": cinderCurr.Snapshots,
			},
		}
	}

	WriteJSON(w, http.StatusOK, resp)
}

```

```go
// main.go 추가

http.HandleFunc("/quota/applyProfile", httph.NewApplyProfileHandler(osc))
```

**(2) 실행 확인** 

엔드포인트 실행 확인을 위해, 총 4가지의 테스트를 진행한다. 

- `basic profile` dryRun 테스트
- `basic profile` 적용 테스트
- `lab profile` dryRun 테스트
- `lab profile` 적용 테스트

**(2-1) dryRun 테스트** 

```go
curl -sS -X POST http://localhost:8080/quota/applyProfile \
  -H 'Content-Type: application/json' \
  -d '{"projectId":"144ba567a5db4334bce43a8c3b54f710","profile":"basic","dryRun":true,"includeDiff":true}' | jq .
```

![current와 basic profile quota의 diff 출력]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%2010.png)

current와 basic profile quota의 diff 출력

**(2-2) `basic profile` 적용 테스트 (dryRun = false)**

```go
curl -sS -X POST http://localhost:8080/quota/applyProfile \
  -H 'Content-Type: application/json' \
  -d '{"projectId":"144ba567a5db4334bce43a8c3b54f710","profile":"basic","dryRun":false,"includeDiff":true}' | jq .
```

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%2011.png)

**(2-3) `lab profile` dryRun 테스트**

```go
url -sS -X POST http://localhost:8080/quota/applyProfile \
  -H 'Content-Type: application/json' \
  -d '{"projectId":"144ba567a5db4334bce43a8c3b54f710","profile":"lab","dryRun":true,"includeDiff":true}' | jq .
```

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%2012.png)

(2-4) `lab profile` 적용 테스트

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%2013.png)

## 5. 결론

### 5-1. 구현 내용 정리

- 기본 환경 세팅, Keystone 인증, 프로젝트별 Quota 조회/설정까지 구현·검증 완료.
- 프로파일 기반(dry-run/적용) 플로우로 운영 전 검증과 안전한 변경이 가능.
- 다음 단계는 자원 라이프사이클(할당/회수)과 모니터링을 추가하는 것.

### **5-2. 엔드포인트**

**인증/헬스**

- GET /healthz: 서버 상태 확인
- GET /auth/check: X-Auth-Token(옵션) 토큰 인트로스펙트

**쿼터 조회/설정**

- GET /quota/current?projectId=<ID>: Nova/Cinder 현재 쿼터 상세 조회
- POST /quota/apply: 개별 값 기반 쿼터 적용
    - 요청: { "projectId": "...", "nova": {...}, "cinder": {...} }
- POST /quota/applyProfile: 프로파일 기반 계획/적용
    - 요청: { "projectId":"...", "profile":"basic|lab", "dryRun":true|false, "includeDiff":true|false }
    - 동작: dryRun=true면 계획/현재/diff만, false면 실제 적용 후 최신 상태 반환

### 5-3. 다음 단계

**자원 할당(Provisioning)**

- Nova: 인스턴스 생성(이미지/플레이버/네트워크/키페어), 부팅 후 상태 확인
- Cinder: 볼륨 생성(크기/타입), 인스턴스에 어태치
- 사전 검증: 현재 쿼터와 사용량 체크 → 부족 시 400 반환
- 타임아웃/재시도/아이템포턴시 키 도입

**자원 회수(Deprovisioning)**

- 서버 삭제(디태치→볼륨 삭제 옵션), 고아 리소스 정리
- 실패 시 보상 트랜잭션(rollback) 가이드

**모니터링**

- 구조화 로그, 요청 트레이스ID
- 상태 메트릭(성공/실패율, 지연시간), 쿼터/사용량 대시보드
- 경보(적용 실패, 사용률 임계 초과)

### 5-4. 자료

- **깃헙 레포지토리**  [https://github.com/windylung/openstack-infra-manager](https://github.com/windylung/openstack-infra-manager)

[현재 단계까지의 Go code file]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/quota-api.zip)

현재 단계까지의 Go code file