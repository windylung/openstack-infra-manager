# (4) Quota ì„¤ì •-2

## 1. ë°°ê²½

[(3) Quota ì„¤ì •-1](https://www.notion.so/3-Quota-1-254e19595aec803c92d6da0a4cf0b53a?pvs=21)

ì•ì„  Quota ì„¤ì •ì—ì„œëŠ” ê³ ì •ëœ ê°’ì„ Quotaë¡œ ì„¤ì •í•˜ì˜€ë‹¤. 

---

## 2. ê°œìš”

**(ë°©ì•ˆ2) Profile ì„¤ì • :** ê³¼ëª©(í”„ë¡œì íŠ¸)ì— ë¯¸ë¦¬ ì •í•œ í”„ë¡œíŒŒì¼(Basic/Lab)ì„ ì„ íƒí•´ ê³ ì •ëœ vCPU/RAM/Disk ìƒí•œì„ í•œ ë²ˆì— ì ìš©í•˜ëŠ” ë°©ì‹.

**(ë°©ì•ˆ3) ìˆ˜ì—… ë‹¨ìœ„ ìœ ë™ì  ì„¤ì •:** í•™ìƒìˆ˜Â·í•™ìƒë‹¹ VMÂ·VMë‹¹ ìì›Â·í—¤ë“œë£¸ì„ ì…ë ¥í•´ ê³„ì‚°ì‹ìœ¼ë¡œ ìƒí•œì„ ì‚°ì¶œ ë° ì ìš©

(ë°©ì•ˆ2)ì„ Go Serverë¥¼ ë„ì…í•˜ì—¬ ê°œë°œí•˜ê³ ì í•œë‹¤.

---

## 3. Go ì„œë²„ êµ¬ì¶• ì‹¤ìŠµ

### 3-1. ì•„í‚¤í…ì²˜ ê°œìš”

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image.png)

- Go â†’ Keystone: â€œauth/token + catalogâ€
- Go â†’ Nova: â€œPUT/GET /compute/v2.1/os-quota-sets/{project_id}â€
- Go â†’ Cinder: â€œPUT/GET /volume/v3/{admin_project_id}/os-quota-sets/{project_id}â€

---

### 3-2. Go ì„œë²„ ì—”ë“œí¬ì¸íŠ¸ ì„¤ê³„

`POST /quota/applyProfile`

**Request Body**

```json
{ "projectId": "<ëŒ€ìƒ ê³¼ëª© í”„ë¡œì íŠ¸ ID>", "profile": "basic", "dryRun": false }
```

- `profile`" basic" ë˜ëŠ” "lab".
- `dryRun`=trueë©´ ê³„ì‚°/ê²€ì¦ë§Œ í•˜ê³  ì‹¤ì œ ë³€ê²½ì€ ì•ˆ í•¨.

**Response**

```json
{
  "plan": { "cores":8, "ramMB":16384, "instances":10, "gigabytes":100, "volumes":10, "snapshots":10 },
  "diff": { "nova": {...}, "cinder": {...} }, 
  "applied": true
}
```

- `plan`: ì´ë²ˆì— ì ìš©í•˜ë ¤ëŠ” ëª©í‘œê°’.
- `diff`: ê¸°ì¡´ê°’ ëŒ€ë¹„ ë³€ê²½ì (ê²€ì¦Â·ê°ì‚¬ìš©).
- `applied`: ì‹¤ì œ ë°˜ì˜ ì—¬ë¶€(dryRunì´ë©´ false).

- ë©”ëª¨ (ë‚´ë¶€ ë™ì‘ / ì‹¤íŒ¨ ì˜ˆì™¸ ì²˜ë¦¬ ì •ì±…)
    
    # Go ì„œë²„ ë‚´ë¶€ ë™ì‘(ìš”ì²­ 1íšŒ ì²˜ë¦¬ í”Œë¡œìš°)
    
    1. **ì…ë ¥ ê²€ì¦**
        - `projectId` ì¡´ì¬/í˜•ì‹ ì²´í¬.
        - `profile âˆˆ {basic, lab}` í™•ì¸.
    2. **í”„ë¡œíŒŒì¼ ë¡œë“œ**
        - ì„œë²„ ë‚´ ìƒìˆ˜ í…Œì´ë¸”:
            - **basic**: vCPU=8, RAM=16384MB(16GiB), instances=10, gigabytes=100, volumes=10, snapshots=10
            - **lab**: vCPU=16, RAM=32768MB(32GiB), instances=20, gigabytes=200, volumes=20, snapshots=20
    3. **ì¸ì¦ & ì—”ë“œí¬ì¸íŠ¸ í™•ì •**
        - Keystoneì— **ìŠ¤ì½”í”„ í† í°** ë°œê¸‰(ë˜ëŠ” ìºì‹œëœ í† í° ì¬ì‚¬ìš©).
        - service catalogì—ì„œ **Nova/Cinder public URL** í™•ì¸.
        - í† í° ë§Œë£Œ ì‹œ ìë™ ì¬ë°œê¸‰(401 ê°ì§€ â†’ ì¬ì‹œë„).
    4. **ì‚¬ì „ ì ê²€(Preflight)**
        - **í˜„ì¬ ì¿¼í„° ì¡°íšŒ**
            - Nova: `GET /compute/v2.1/os-quota-sets/{project_id}`
            - Cinder: `GET /volume/v3/{admin_project_id}/os-quota-sets/{project_id}`
        - **ì‚¬ìš©ëŸ‰/ìƒì„¸ ì¡°íšŒ(ì„ íƒ)**
            - Nova: `GET .../detail` (in_useÂ·limit í™•ì¸)
            - Cinder: `GET ...?usage=true`
        - **ìš©ëŸ‰/ì •ì±… ê°€ë“œ(ì„ íƒ)**
            - í•˜ì´í¼ë°”ì´ì € ëŒ€ëµ ìš©ëŸ‰: `GET /os-hypervisors/statistics`
            - ëª©í‘œ limitê°€ í˜„ì¬ in_useë³´ë‹¤ ë‚®ìœ¼ë©´ ì‹¤íŒ¨ ì²˜ë¦¬.
    5. **diff ê³„ì‚°**
        - ê¸°ì¡´ê°’ â†” í”„ë¡œíŒŒì¼ ëª©í‘œê°’ ì°¨ì´ë¥¼ ë§Œë“¤ì–´ ì‘ë‹µì— í¬í•¨(ê°ì‚¬/ë¦¬ë·° ìš©).
    6. **dryRun ì²˜ë¦¬**
        - `dryRun=true`ë©´ ì—¬ê¸°ì„œ ì¢…ë£Œ(ê³„ì‚° ê²°ê³¼ë§Œ ë°˜í™˜).
    7. **ì‹¤ ì ìš©(íŠ¸ëœì­ì…˜ì  ì²˜ë¦¬)**
        - Nova PUT â†’ ì„±ê³µ ì‹œ Cinder PUT.
        - **ë¶€ë¶„ ì‹¤íŒ¨ ë°©ì§€ ì „ëµ**
            - ë‘ ì„œë¹„ìŠ¤ ëª¨ë‘ ì‚¬ì „ ê²€ì¦ ì„±ê³µ ì‹œì—ë§Œ ì‹¤í–‰
            - í•œìª½ ì‹¤íŒ¨ ì‹œ, ê°€ëŠ¥í•˜ë©´ ì´ë¯¸ ë³€ê²½ëœ ìª½ì— **ë¡¤ë°± PUT** ì‹œë„(ë°±ì—…ê°’ìœ¼ë¡œ ë³µê·€)
            - ì‹¤íŒ¨ë¥¼ ì‘ë‹µì— ëª…í™•íˆ ê¸°ë¡
    8. **ì‚¬í›„ ê²€ì¦(Post-apply)**
        - Nova/Cinder ê°ê° **ì¬ì¡°íšŒ**ë¡œ ëª©í‘œê°’ ë°˜ì˜ í™•ì¸.
        - ê²°ê³¼(ìµœì¢…ê°’/ë³€ê²½ ë‚´ì—­) ì‘ë‹µ.
    9. **ê°ì‚¬ ë¡œê·¸/ë°±ì—…(ì„ íƒ)**
        - ì ìš© ì „ ì¿¼í„° JSONì„ íŒŒì¼/DBì— ì €ì¥(ì¢…ê°• ì›ë³µìš©).
        - ëˆ„ê°€/ì–¸ì œ/ì–´ë–¤ profileì„ ì–´ëŠ projectì— ì ìš©í–ˆëŠ”ì§€ ë¡œê¹….
    
    ---
    
    # ì‹¤íŒ¨Â·ì˜ˆì™¸ ì²˜ë¦¬ ì •ì±…
    
    - **401 Unauthorized**: í† í° ë§Œë£Œ â†’ ì¬ì¸ì¦ í›„ 1íšŒ ì¬ì‹œë„.
    - **403 Forbidden**: ê¶Œí•œ ë¶€ì¡±(í”„ë¡œì íŠ¸/ì—­í•  í™•ì¸ í•„ìš”) â†’ ì—ëŸ¬ ë°˜í™˜.
    - **400 Bad Request**: ê²½ë¡œÂ·JSONÂ·ë‹¨ìœ„ ì˜¤ë¥˜ â†’ ì›ì¸ ë©”ì‹œì§€ ê·¸ëŒ€ë¡œ ì‘ë‹µ.
    - **Cinder ê²½ë¡œ ì˜¤ë¥˜ ë°©ì§€**: í•­ìƒ `/{ADMIN_PROJECT_ID}/os-quota-sets/{TARGET_PROJECT_ID}` ì‚¬ìš©.
    - **ë‹¨ìœ„ ì£¼ì˜**: Nova RAMì€ **MB**, Cinder gigabytesëŠ” **GB**.
    - **ë¶€ë¶„ ì„±ê³µ**: Nova ì„±ê³µÂ·Cinder ì‹¤íŒ¨ ì‹œ, Novaë¥¼ ë°±ì—…ê°’ìœ¼ë¡œ ì¦‰ì‹œ ë³µêµ¬ ì‹œë„.

---

### 3-3. Go ì„œë²„ êµ¬ì¶•

**(0) ê°œìš”** 

mac mini, Sequoia v15.6, Cursor

**(1) í”„ë¡œì íŠ¸ ì´ˆê¸°í™”**

```bash
mkdir -p ~/quota-api && cd ~/quota-api
go mod init example.com/quotaapi
```

**(2) ì„œë²„ ê¸°ë³¸ ì½”ë“œ ì‘ì„±** 

1. **/healthz**: ì„œë²„ ìƒíƒœ í™•ì¸ìš© (GET ìš”ì²­)
2. **/quota/applyProfile**: Quota Profile ì ìš©(POSTÂ ìš”ì²­) - ì•„ì§Â ë¯¸êµ¬í˜„

```go
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
)

// í—¬í¼: JSON ì‘ë‹µì„ ì“°ëŠ” í•¨ìˆ˜
func writeJSON(w http.ResponseWriter, code int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	_ = json.NewEncoder(w).Encode(v)
}

// GET /healthz â†’ ì„œë²„ ì‚´ì•„ìˆëŠ”ì§€ í™•ì¸ìš©
func healthHandler(w http.ResponseWriter, r *http.Request) {
	writeJSON(w, http.StatusOK, map[string]any{"ok": true})
}

// POST /quota/applyProfile
type applyReq struct {
	ProjectID   string `json:"projectId"`
	Profile     string `json:"profile"`     // "basic" | "lab"
	DryRun      bool   `json:"dryRun"`      // ì ìš© ë¯¸ë¦¬ë³´ê¸°
	IncludeDiff bool   `json:"includeDiff"` // ë³€ê²½ì  í¬í•¨í• ì§€
}

func applyProfileHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		writeJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "POST only"})
		return
	}
	var req applyReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "bad json: " + err.Error()})
		return
	}
	// ì•„ì§ êµ¬í˜„ ì „: ì…ë ¥ ì—ì½” + Not Implemented í‘œì‹œ
	writeJSON(w, http.StatusNotImplemented, map[string]any{
		"received": req,
		"message":  "applyProfile not implemented yet",
	})
}

func main() {
	http.HandleFunc("/healthz", healthHandler)
	http.HandleFunc("/quota/applyProfile", applyProfileHandler)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	log.Println("listening on :" + port)
	log.Fatal(http.ListenAndServe(":"+port, nil))
}

```

- ì£¼ìš” ì½”ë“œ ì„¤ëª…
    
    ```go
    func applyProfileHandler(w http.ResponseWriter, r *http.Request) {
    	// r.Methodë¡œ ìš”ì²­ì˜ HTTP ë©”ì„œë“œë¥¼ í™•ì¸
    	// POSTê°€ ì•„ë‹ˆë©´ "405 Method Not Allowed" ì—ëŸ¬ ë°˜í™˜
    	// returnìœ¼ë¡œ í•¨ìˆ˜ ì¢…ë£Œ
    	if r.Method != http.MethodPost {
    		writeJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "POST only"})
    		return
    	}
    
    	// 	req ë³€ìˆ˜ë¥¼ applyReq íƒ€ì…ìœ¼ë¡œ ì„ ì–¸
    	// r.Bodyì—ì„œ JSON ë°ì´í„°ë¥¼ ì½ì–´ì„œ req êµ¬ì¡°ì²´ì— íŒŒì‹±
    	// íŒŒì‹± ì‹¤íŒ¨ì‹œ "400 Bad Request" ì—ëŸ¬ ë°˜í™˜
    	var req applyReq
    	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "bad json: " + err.Error()})
    		return
    	}
    
    	// ì•„ì§ êµ¬í˜„ ì „: ì…ë ¥ ì—ì½” + Not Implemented í‘œì‹œ
    	writeJSON(w, http.StatusNotImplemented, map[string]any{
    		"received": req,
    		"message":  "applyProfile not implemented yet",
    	})
    }
    ```
    

**(3) ì‹¤í–‰ í™•ì¸**

```bash
 go run . #ì„œë²„ ì‹¤í–‰
```

```bash
# ë‹¤ë¥¸ í„°ë¯¸ë„ì—ì„œ ìˆ˜í–‰
curl -s http://127.0.0.1:8080/healthz | jq .

curl -s -X POST http://127.0.0.1:8080/quota/applyProfile \
  -H 'content-type: application/json' \
  -d '{"projectId":"demo","profile":"basic","dryRun":true,"includeDiff":true}' | jq .
```

- ì‹¤í–‰ ê²°ê³¼
    
    API ìš”ì²­ì— ì í•©í•œ ì‘ë‹µì´ ì˜¨ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. 
    
    ![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%201.png)
    

---

### 3-4. í”„ë¡œíŒŒì¼ ì •ì˜ ë° ê²€ì¦

**(1) í”„ë¡œíŒŒì¼ ì½”ë“œ ì‘ì„±** 

```go
# í”„ë¡œíŒŒì¼ ì •ì˜
var profiles = map[string]plan{
	"basic": {Cores: 8, RAMMB: 16384, Instances: 10, Gigabytes: 100, Volumes: 10, Snapshots: 10},
	"lab":   {Cores: 16, RAMMB: 32768, Instances: 20, Gigabytes: 200, Volumes: 20, Snapshots: 20},
}
```

```go
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"strings"
)

// ì¶”ê°€ 
// plan: í”„ë¡œíŒŒì¼ì— ë”°ë¥¸ ëª©í‘œ ì¿¼í„° ê°’
type plan struct {
	Cores     int `json:"cores"`     // vCPU
	RAMMB     int `json:"ramMB"`     // RAM in MB
	Instances int `json:"instances"` // ì¸ìŠ¤í„´ìŠ¤ ìˆ˜
	Gigabytes int `json:"gigabytes"` // Cinder ë””ìŠ¤í¬ ì´ëŸ‰(GB)
	Volumes   int `json:"volumes"`
	Snapshots int `json:"snapshots"`
}

// ì¶”ê°€ 
// í”„ë¡œíŒŒì¼ë³„ ì¿¼í„° ì„¤ì •
var profiles = map[string]plan{
	"basic": {Cores: 8, RAMMB: 16384, Instances: 10, Gigabytes: 100, Volumes: 10, Snapshots: 10},
	"lab":   {Cores: 16, RAMMB: 32768, Instances: 20, Gigabytes: 200, Volumes: 20, Snapshots: 20},
}

type applyReq struct {
	ProjectID   string `json:"projectId"`
	Profile     string `json:"profile"`     // "basic" | "lab"
	DryRun      bool   `json:"dryRun"`      // ì ìš© ë¯¸ë¦¬ë³´ê¸°
	IncludeDiff bool   `json:"includeDiff"` // ë³€ê²½ì  í¬í•¨í• ì§€
}

// JSON ì‘ë‹µ í—¬í¼ í•¨ìˆ˜
func writeJSON(w http.ResponseWriter, code int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	_ = json.NewEncoder(w).Encode(v)
}

// GET /healthz â†’ ì„œë²„ ìƒíƒœ í™•ì¸
func healthHandler(w http.ResponseWriter, r *http.Request) {
	writeJSON(w, http.StatusOK, map[string]any{"ok": true})
}

func applyProfileHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		writeJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "POST only"})
		return
	}
	var req applyReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "bad json: " + err.Error()})
		return
	}

	// í”„ë¡œì íŠ¸ ID ê²€ì¦
	if strings.TrimSpace(req.ProjectID) == "" {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "projectId is required"})
		return
	}
	
	// ì¶”ê°€ 
	// í”„ë¡œíŒŒì¼ ê²€ì¦ ë° plan ê°€ì ¸ì˜¤ê¸°
	p, ok := profiles[strings.ToLower(req.Profile)]
	if !ok {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "unknown profile (use 'basic' or 'lab')"})
		return
	}

	// ì¶”ê°€ 
	// plan ë°˜í™˜ (ì‹¤ì œ ì ìš©ì€ ë‹¤ìŒ ë‹¨ê³„)
	resp := map[string]any{
		"plan":      p,          // ëª©í‘œ ì¿¼í„° ê°’
		"applied":   false,      // ì•„ì§ ì ìš© ì•ˆ í•¨
		"dryRun":    req.DryRun, // ìš”ì²­ê°’ ê·¸ëŒ€ë¡œ í‘œì‹œ
		"message":   "plan computed. Next step: fetch current quotas & diff, then apply.",
		"projectId": req.ProjectID,
		"profile":   strings.ToLower(req.Profile),
	}
	writeJSON(w, http.StatusOK, resp)
}

func main() {
	http.HandleFunc("/healthz", healthHandler)
	http.HandleFunc("/quota/applyProfile", applyProfileHandler)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	log.Println("listening on :" + port)
	log.Fatal(http.ListenAndServe(":"+port, nil))
}

```

**(2) ì‹¤í–‰ í™•ì¸** 

```bash
go run .
```

```bash
# ë‹¤ë¥¸ í„°ë¯¸ë„ì—ì„œ API ìš”ì²­

#(1) profile: basic
curl -s -X POST http://127.0.0.1:8080/quota/applyProfile \
  -H 'content-type: application/json' \
  -d '{"projectId":"demo","profile":"basic","dryRun":true,"includeDiff":true}' | jq .

#(2) profile: lab
curl -s -X POST http://127.0.0.1:8080/quota/applyProfile \
  -H 'content-type: application/json' \
  -d '{"projectId":"demo","profile":"lab","dryRun":true,"includeDiff":true}' | jq .

#(3) profile: non-profile
curl -s -X POST http://127.0.0.1:8080/quota/applyProfile \
  -H 'content-type: application/json' \
  -d '{"projectId":"demo","profile":"non-profile","dryRun":true,"includeDiff":true}' | jq .
```

**(3) ì‹¤í–‰ ê²°ê³¼**

![Screenshot 2025-08-20 at 11.35.14â€¯AM.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/Screenshot_2025-08-20_at_11.35.14_AM.png)

- request ë‚´ profileì— ë”°ë¼ ë§¤í•‘ì´ ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

---

## 4. Openstack ì„œë¹„ìŠ¤ ì—°ë™

### 4-1. Keystone ì¸ì¦

í˜„ì¬ Go Server ë‚´ API ì‘ë™ë§Œ í™•ì¸ë˜ì—ˆë‹¤. **Openstack ë‚´ Keystone, nova, cinderì™€ ì—°ê²°ì´ í•„ìš”í•˜ë‹¤.**

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%202.png)

**(1) ë””ë ‰í† ë¦¬ êµ¬ì¡° ì„¤ì •** 

```markdown
quota-api/
â”œâ”€ cmd/server/              â† ì‹¤í–‰ ì—”íŠ¸ë¦¬(ë°”ì´ë„ˆë¦¬ ìƒì„± ì§€ì )
â”œâ”€ internal/                â† ì•±ì˜ ë‚´ë¶€ êµ¬í˜„(ìº¡ìŠí™”)
â”‚  â”œâ”€ config/               â† í™˜ê²½ë³€ìˆ˜ ë¡œë”©/ê²€ì¦
â”‚  â”œâ”€ http/                 â† HTTP í•¸ë“¤ëŸ¬(ìš”ì²­/ì‘ë‹µë§Œ ë‹´ë‹¹)
â”‚  â””â”€ openstack/            â† Keystone ë“± ì™¸ë¶€(OpenStack) ì—°ë™
â””â”€ go.mod                   â† Go ëª¨ë“ˆ ì„¤ì •(ì˜ì¡´ì„±/ëª¨ë“ˆ ê²½ë¡œ)
```

**(1) gophercloud ì„¤ì¹˜**

```go
# ë¡œì»¬ ì»´í“¨í„° ë‚´ í„°ë¯¸ë„
# Go ëª¨ë“ˆ ì˜ì¡´ì„± ì„¤ì¹˜ 
go get github.com/gophercloud/gophercloud@latest
```

gophercloudëŠ” Openstack ìš© Go SDKë¡œì„œ, ê° ì„œë¹„ìŠ¤ì˜ í´ë¼ì´ì–¸íŠ¸, íƒ€ì…, í—¬í¼ë¥¼ ì œê³µí•œë‹¤.

**(2) .env í™˜ê²½ë³€ìˆ˜ ì„¤ì •**

```bash
export OS_AUTH_URL=http://192.168.64.4/identity/v3
export OS_USERNAME=admin
export OS_PASSWORD=secret
export OS_USER_DOMAIN_ID=default
export OS_PROJECT_NAME=admin
export OS_REGION_NAME=RegionOne
```

**(3) ì½”ë“œ ì‘ì„±**

![ë””ë ‰í† ë¦¬ êµ¬ì¡°]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%203.png)

ë””ë ‰í† ë¦¬ êµ¬ì¡°

```go
// auth.go
package openstack

import (
	"github.com/gophercloud/gophercloud"
	"github.com/gophercloud/gophercloud/openstack"

	"example.com/quotaapi/internal/config"
)

// Keystone ë¡œê·¸ì¸: Provider(í† í° ë³´ê´€) + Identity v3 í´ë¼ì´ì–¸íŠ¸ ìƒì„±
func NewIdentity(c *config.Config) (*gophercloud.ProviderClient, *gophercloud.ServiceClient, error) {
	ao := gophercloud.AuthOptions{
		IdentityEndpoint: c.AuthURL,
		Username:         c.Username,
		Password:         c.Password,
		DomainID:         c.UserDomainID,
		TenantName:       c.ProjectName, // í”„ë¡œì íŠ¸ ìŠ¤ì½”í”„
		AllowReauth:      true,
	}
	provider, err := openstack.AuthenticatedClient(ao)
	if err != nil {
		return nil, nil, err
	}
	ident, err := openstack.NewIdentityV3(provider, gophercloud.EndpointOpts{
		Region: c.RegionName,
	})
	if err != nil {
		return nil, nil, err
	}
	return provider, ident, nil
}

// í† í° ì¡°íšŒ(X-Subject-Token). subjectTokenì´ ë¹„ì—ˆìœ¼ë©´ ì„œë¹„ìŠ¤ í† í° ìì²´ ì¡°íšŒ.
func IntrospectToken(ident *gophercloud.ServiceClient, provider *gophercloud.ProviderClient, subjectToken string) (map[string]any, error) {
	if subjectToken == "" {
		subjectToken = provider.TokenID
	}
	var raw map[string]any
	_, err := ident.Get(
		ident.ServiceURL("auth", "tokens"),
		&raw,
		&gophercloud.RequestOpts{
			MoreHeaders: map[string]string{
				"X-Subject-Token": subjectToken,
			},
		},
	)
	return raw, err
}

```

```go
// auth_handler.go
package http

import (
	"encoding/json"
	"log"
	"net/http"

	"example.com/quotaapi/internal/config"
	osauth "example.com/quotaapi/internal/openstack"
)

// ê³µí†µ JSON ì‘ë‹µ
func WriteJSON(w http.ResponseWriter, code int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	_ = json.NewEncoder(w).Encode(v)
}

// GET /auth/check
// - í—¤ë” X-Auth-Token ì´ ìˆìœ¼ë©´ ê·¸ í† í°ì„ ê²€ì¦
// - ì—†ìœ¼ë©´ ì„œë¹„ìŠ¤ í† í°(í™˜ê²½ë³€ìˆ˜ ê³„ì •ìœ¼ë¡œ ë°œê¸‰ëœ í† í°)ì„ ê²€ì¦
func NewAuthCheckHandler(cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodGet {
			WriteJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "GET only"})
			return
		}
		provider, ident, err := osauth.NewIdentity(cfg)
		if err != nil {
			WriteJSON(w, http.StatusBadGateway, map[string]string{"error": "keystone auth error: " + err.Error()})
			return
		}
		subject := r.Header.Get("X-Auth-Token")
		raw, err := osauth.IntrospectToken(ident, provider, subject)
		if err != nil {
			WriteJSON(w, http.StatusBadGateway, map[string]string{"error": "token introspection failed: " + err.Error()})
			return
		}

		// ì•ˆì „ ìºìŠ¤íŒ…
		token, _ := raw["token"].(map[string]any)
		user, _ := token["user"].(map[string]any)
		project, _ := token["project"].(map[string]any)
		roles, _ := token["roles"].([]any)
		log.Println(raw["token"])

		WriteJSON(w, http.StatusOK, map[string]any{
			"auth": "ok",
			"user": map[string]any{
				"id":     safe(user, "id"),
				"name":   safe(user, "name"),
				"domain": user["domain"],
			},
			"project": map[string]any{
				"id":     safe(project, "id"),
				"name":   safe(project, "name"),
				"domain": project["domain"],
			},
			"token": map[string]any{
				"issued_at":  safe(token, "issued_at"),
				"expires_at": safe(token, "expires_at"),
			},
			"roles": roles, // [{id,name}, ...]
		})
	}
}

func safe(m map[string]any, k string) any {
	if m == nil {
		return ""
	}
	if v, ok := m[k]; ok && v != nil {
		return v
	}
	return ""
}

```

```go
package config

import (
	"errors"
	"os"

	"github.com/joho/godotenv"
)

type Config struct {
	AuthURL      string // OS_AUTH_URL
	Username     string // OS_USERNAME
	Password     string // OS_PASSWORD
	UserDomainID string // OS_USER_DOMAIN_ID
	ProjectName  string // OS_PROJECT_NAME
	RegionName   string // OS_REGION_NAME
}

func Load() (*Config, error) {
	_ = godotenv.Load(".env")

	c := &Config{
		AuthURL:      os.Getenv("OS_AUTH_URL"),
		Username:     os.Getenv("OS_USERNAME"),
		Password:     os.Getenv("OS_PASSWORD"),
		UserDomainID: os.Getenv("OS_USER_DOMAIN_ID"),
		ProjectName:  os.Getenv("OS_PROJECT_NAME"),
		RegionName:   os.Getenv("OS_REGION_NAME"),
	}
	if c.AuthURL == "" || c.Username == "" || c.Password == "" ||
		c.UserDomainID == "" || c.ProjectName == "" || c.RegionName == "" {
		return nil, errors.New("missing one or more OpenStack envs: OS_AUTH_URL, OS_USERNAME, OS_PASSWORD, OS_USER_DOMAIN_ID, OS_PROJECT_NAME, OS_REGION_NAME")
	}
	return c, nil
}

```

**(4) ì‹¤í–‰ í™•ì¸**

```go
// main.goê°€ ìœ„ì¹˜í•œ server directoryì—ì„œ ì§„í–‰ 
go run .
```

```go
curl -sS "http://localhost:8080/healthz" | jq .

curl -sS "http://localhost:8080/auth/check" | jq .
```

- ì‹¤í–‰ ê²°ê³¼
    
    ![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%204.png)
    
    ```json
    // curl -sS "http://localhost:8080/auth/check" | jq .
    {
      "auth": "ok",
      "project": {
        "domain": {
          "id": "default",
          "name": "Default"
        },
        "id": "144ba567a5db4334bce43a8c3b54f710",
        "name": "admin"
      },
      "roles": [
        {
          "id": "4a7a581ed3944bd1a85d3ff08c5fffb9",
          "name": "reader"
        },
        {
          "id": "a0c9ac9d7f37465d9b779348d4c95019",
          "name": "manager"
        },
        {
          "id": "183833c139524b829a28e9cfde689d1d",
          "name": "member"
        },
        {
          "id": "fe38aced0ab04ca3866a79ec1b1edd45",
          "name": "admin"
        }
      ],
      "token": {
        "expires_at": "2025-08-27T00:30:10.000000Z",
        "issued_at": "2025-08-26T23:30:10.000000Z"
      },
      "user": {
        "domain": {
          "id": "default",
          "name": "Default"
        },
        "id": "0eead67f8a7b4336a730d213ab37bb0b",
        "name": "admin"
      }
    }
    ```
    

**(5) OpenStack Client**

Keystone ì¸ì¦ì„ ê±°ì¹œ í›„ ë§Œë“¤ì–´ì§€ëŠ” **provider, ident** ë‘ê°€ì§€ ìœ í˜•ì˜ clientê°€ ì¡´ì¬í•œë‹¤. 

**(5-1) provider**

- `provider, err := openstack.AuthenticatedClient(ao)`
- OpenStack ì „ì²´ API ìš”ì²­ì˜ ê¸°ë°˜ì´ ë˜ëŠ” ì¸ì¦ëœ í´ë¼ì´ì–¸íŠ¸
- ë‹¤ë¥¸ ì„œë¹„ìŠ¤ í´ë¼ì´ì–¸íŠ¸(compute, network, identity, â€¦)ë¥¼ ë§Œë“¤ ë•Œ ê³µí†µ ë¶€ëª¨ë¡œ ì „ë‹¬í•´ì•¼ í•˜ëŠ” ê°ì²´
- Keystoneì— ë¡œê·¸ì¸í•´ì„œ í† í°ê³¼ ì¹´íƒˆë¡œê·¸(ì—”ë“œí¬ì¸íŠ¸ ëª©ë¡) ë¥¼ ê°€ì ¸ì˜¨ë‹¤
- ì„¸ë¶€ í•­ëª©
    - Keystoneì´ ë°œê¸‰í•œ Token
    - Token ë§Œë£Œ ì‹œê°„
    - ì¹´íƒˆë¡œê·¸(ì–´ë–¤ ì„œë¹„ìŠ¤ê°€ ìˆê³ , ì–´ë””ì— ì ‘ì†í•´ì•¼ í•˜ëŠ”ì§€)
    - Re-authentication ì˜µì…˜
- provider (log)
    
    ```json
    {
      "token": {
        "audit_ids": ["KbahUf1oQ0CjCbsh8lFdcQ"],
        "catalog": [
          {
            "id": "1305ba8aa38546c38f5975f67b306f30",
            "name": "nova",
            "type": "compute",
            "endpoints": [
              {
                "id": "7746914cfce74837a2af01afdd8341ec",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/compute/v2.1"
              }
            ]
          },
          {
            "id": "1aec7f81009a4298bf7bdcab9d665c02",
            "name": "keystone",
            "type": "identity",
            "endpoints": [
              {
                "id": "1717dc020ae747a3a73c750a817da6c5",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/identity"
              }
            ]
          },
          {
            "id": "6bf73b34fca047809ccd93b7bb6bbb82",
            "name": "neutron",
            "type": "network",
            "endpoints": [
              {
                "id": "03bbbb933cfc44f884bb1050e9d9e1ed",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/networking"
              }
            ]
          },
          {
            "id": "7a09c659563b42968e271808e9284e56",
            "name": "cinder",
            "type": "block-storage",
            "endpoints": [
              {
                "id": "cbaac750652546f8947ebf4bb32b6895",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/volume/v3"
              }
            ]
          },
          {
            "id": "7cf962b57aa94bf19482221d73703600",
            "name": "glance",
            "type": "image",
            "endpoints": [
              {
                "id": "3faf8a7ee2af46ceb971f8d8121ebad2",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/image"
              }
            ]
          },
          {
            "id": "c8302fde18bf48f28f9d899c3045e713",
            "name": "nova_legacy",
            "type": "compute_legacy",
            "endpoints": [
              {
                "id": "cd90f7cb90604db794aef48e29c4c52f",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/compute/v2/144ba567a5db4334bce43a8c3b54f710"
              }
            ]
          },
          {
            "id": "efa2258cedae43dc82c3ce37ad0096f1",
            "name": "placement",
            "type": "placement",
            "endpoints": [
              {
                "id": "be853be6e35c4713bddd68d64c2f5a63",
                "interface": "public",
                "region": "RegionOne",
                "region_id": "RegionOne",
                "url": "http://192.168.64.4/placement"
              }
            ]
          }
        ],
        "expires_at": "2025-08-27T00:44:48.000000Z",
        "issued_at": "2025-08-26T23:44:48.000000Z",
        "is_domain": false,
        "methods": ["password"],
        "project": {
          "id": "144ba567a5db4334bce43a8c3b54f710",
          "name": "admin",
          "domain": {
            "id": "default",
            "name": "Default"
          }
        },
        "roles": [
          { "id": "4a7a581ed3944bd1a85d3ff08c5fffb9", "name": "reader" },
          { "id": "a0c9ac9d7f37465d9b779348d4c95019", "name": "manager" },
          { "id": "183833c139524b829a28e9cfde689d1d", "name": "member" },
          { "id": "fe38aced0ab04ca3866a79ec1b1edd45", "name": "admin" }
        ],
        "user": {
          "id": "0eead67f8a7b4336a730d213ab37bb0b",
          "name": "admin",
          "domain": {
            "id": "default",
            "name": "Default"
          },
          "password_expires_at": null
        }
      }
    }
    
    ```
    

**(5-2) ident**

- `ident, err := openstack.NewIdentityV3(**provider**, gophercloud.EndpointOpts`
- íŠ¹ì • OpenStack ì„œë¹„ìŠ¤(í•´ë‹¹ ì½”ë“œì˜ ê²½ìš° keystone)ì— ì—°ê²°í•˜ê¸° ìœ„í•œ ì„œë¹„ìŠ¤ í´ë¼ì´ì–¸íŠ¸
- provider ê°€ ê°€ì§„ í† í°ê³¼ ì¹´íƒˆë¡œê·¸ë¥¼ ì‚¬ìš©í•´ Identity API ìš”ì²­ ì „ìš© í´ë¼ì´ì–¸íŠ¸ë¥¼ ë§Œë“ ë‹¤
- /v3/users, /v3/projects, /v3/roles ê°™ì€ Identity API ì—”ë“œí¬ì¸íŠ¸ë¥¼ í˜¸ì¶œí•  ë•Œ ì‚¬ìš©

**(5-3) Openstack service client**

OpenStackì€ Nova(Compute), Neutron(Network), Cinder(Block Storage), Glance(Image), Placement â€¦ ë“± **ì„œë¹„ìŠ¤ ë‹¨ìœ„**ë¡œ ë‚˜ë‰˜ì–´ ìˆë‹¤. 

â†’ ê° ì„œë¹„ìŠ¤ì— ì ‘ê·¼í•˜ë ¤ë©´ **ì „ìš© ServiceClientë¥¼ ìƒì„±**í•´ì•¼ í•œë‹¤. 

â†’ **providerë¥¼** ì‚¬ìš©í•˜ì—¬  ServiceClientë¥¼ ìƒì„±í•œë‹¤

---

### 4-2. ì¿¼í„° ì¡°íšŒ

**(1) gophercloud version 2ë¡œ ë³€ê²½**

```go
//ë£¨íŠ¸ ë””ë ‰í† ë¦¬ì—ì„œ 
go get github.com/gophercloud/gophercloud/v2@latest
go mod tidy
```

**(2) .env / configì— AdminProjectId ì¶”ê°€** 

- cinder API í˜¸ì¶œì„ ìœ„í•¨
- `curl -sS "http://localhost:8080/auth/check" | jq .` ë¡œ ì¡°íšŒ ê°€ëŠ¥

```go
package config

import (
	"errors"
	"os"

	"github.com/joho/godotenv"
)

type Config struct {
	AuthURL        string // OS_AUTH_URL
	Username       string // OS_USERNAME
	Password       string // OS_PASSWORD
	UserDomainID   string // OS_USER_DOMAIN_ID
	ProjectName    string // OS_PROJECT_NAME
	RegionName     string // OS_REGION_NAME
	AdminProjectID string // OS_ADMIN_PROJECT_ID // ì¶”ê°€
}

func Load() (*Config, error) {
	_ = godotenv.Load(".env")

	c := &Config{
		AuthURL:        os.Getenv("OS_AUTH_URL"),
		Username:       os.Getenv("OS_USERNAME"),
		Password:       os.Getenv("OS_PASSWORD"),
		UserDomainID:   os.Getenv("OS_USER_DOMAIN_ID"),
		ProjectName:    os.Getenv("OS_PROJECT_NAME"),
		RegionName:     os.Getenv("OS_REGION_NAME"),
		AdminProjectID: os.Getenv("OS_ADMIN_PROJECT_ID"), // ì¶”ê°€
	}
	if c.AuthURL == "" || c.Username == "" || c.Password == "" ||
		c.UserDomainID == "" || c.ProjectName == "" || c.RegionName == "" {
		return nil, errors.New("missing one or more OpenStack envs: OS_AUTH_URL, OS_USERNAME, OS_PASSWORD, OS_USER_DOMAIN_ID, OS_PROJECT_NAME, OS_REGION_NAME, OS_ADMIN_PROJECT_ID")
	}
	return c, nil
}

```

```go
OS_AUTH_URL=http://192.168.64.4/identity/v3
OS_USERNAME=admin
OS_PASSWORD=secret
OS_USER_DOMAIN_ID=default
OS_PROJECT_NAME=admin
OS_REGION_NAME=RegionOne
ADMIN_PROJECT_ID=144ba567a5db4334bce43a8c3b54f710 // ì¶”ê°€
```

**(3) Quota ì¡°íšŒ handler ì¶”ê°€**

```go
// quota_get_handler.go

package http

import (
	"net/http"

	osapi "example.com/quotaapi/internal/openstack"
)

type QuotaGetServer struct {
	OS *osapi.Clients
}

// GET /quota/current?projectId=xxxx
func (s *QuotaGetServer) Current(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		WriteJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "GET only"})
		return
	}

	projectID := r.URL.Query().Get("projectId")
	if projectID == "" {
		WriteJSON(w, http.StatusBadRequest, map[string]string{"error": "missing projectId"})
		return
	}

	nova, nErr := s.OS.GetNovaQuotaDetail(r.Context(), projectID)
	cind, cErr := s.OS.GetCinderQuotaDetail(r.Context(), projectID)
	if nErr != nil || cErr != nil {
		WriteJSON(w, http.StatusBadGateway, map[string]any{
			"error":  "quota read failed",
			"nova":   errString(nErr),
			"cinder": errString(cErr),
		})
		return
	}

	WriteJSON(w, http.StatusOK, map[string]any{
		"projectId": projectID,
		"nova":      nova,
		"cinder":    cind,
	})
}

func errString(err error) any {
	if err == nil {
		return nil
	}
	return err.Error()
}
```

```go
package main
// main.goì— ì¶”ê°€

	qget := &httph.QuotaGetServer{OS: osc}
	http.HandleFunc("/quota/current", qget.Current)

```

**(4) Nova, Cinder service client ìƒì„±** 

```go
//clients.go
package openstack

import (
	"fmt"

	"example.com/quotaapi/internal/config"
	"github.com/gophercloud/gophercloud/v2"
	"github.com/gophercloud/gophercloud/v2/openstack"
)

type Clients struct {
	Provider       *gophercloud.ProviderClient
	Identity       *gophercloud.ServiceClient
	ComputeV2      *gophercloud.ServiceClient
	BlockStorageV3 *gophercloud.ServiceClient
	AdminProjectID string
	Region         string
}

func NewServiceClients(cfg *config.Config) (*Clients, error) {
	provider, ident, err := NewIdentity(cfg)
	if err != nil {
		return nil, fmt.Errorf("keystone auth: %w", err)
	}

	compute, err := openstack.NewComputeV2(provider, gophercloud.EndpointOpts{Region: cfg.RegionName})
	if err != nil {
		return nil, fmt.Errorf("new compute v2: %w", err)
	}

	block, err := openstack.NewBlockStorageV3(provider, gophercloud.EndpointOpts{
		Region:       cfg.RegionName,
		Type:         "block-storage",                // ì¹´íƒˆë¡œê·¸ì— ìˆëŠ” type ê³¼ ë§ì¶¤
		Name:         "cinder",                       // (ì„ íƒ) name ì¼ì¹˜ì‹œì¼œ ë§¤ì¹­ ë” í™•ì‹¤
		Availability: gophercloud.AvailabilityPublic, // public endpoint ì‚¬ìš©
	})
	if err != nil {
		return nil, fmt.Errorf("new blockstorage v3: %w", err)
	}

	return &Clients{
		Provider:       provider,
		Identity:       ident,
		ComputeV2:      compute,
		BlockStorageV3: block,
		AdminProjectID: cfg.AdminProjectID,
		Region:         cfg.RegionName,
	}, nil
}

```

**(5) Quota ì •ë³´ ì¡°íšŒ** 

> **nova GetDetail ë©”ì†Œë“œ ì •ì˜**
> 
> 
> ```
> // GetDetail returns detailed public data about a previously created QuotaSet.
> func GetDetail(ctx context.Context, client *gophercloud.ServiceClient, tenantID string) (r GetDetailResult) {
> 	resp, err := client.Get(ctx, getDetailURL(client, tenantID), &r.Body, nil)
> 	_, r.Header, r.Err = gophercloud.ParseResponse(resp, err)
> 	return
> }
> ```
> 
> **cinder GetUsage ë©”ì†Œë“œ ì •ì˜**
> 
> ```
> // GetUsage returns detailed public data about a previously created QuotaSet.
> func GetUsage(ctx context.Context, client *gophercloud.ServiceClient, projectID string) (r GetUsageResult) {
> 	u := fmt.Sprintf("%s?usage=true", getURL(client, projectID))
> 	resp, err := client.Get(ctx, u, &r.Body, nil)
> 	_, r.Header, r.Err = gophercloud.ParseResponse(resp, err)
> 	return
> }
> ```
> 

```go
// quotas_get.go
package openstack

import (
	"context"
	"fmt"

	cqs "github.com/gophercloud/gophercloud/v2/openstack/blockstorage/v3/quotasets"
	novaqs "github.com/gophercloud/gophercloud/v2/openstack/compute/v2/quotasets"
)

type QuotaDetail struct {
	Limit int `json:"limit"`
	InUse int `json:"in_use"`
}

type NovaQuotaDetail struct {
	Cores     QuotaDetail `json:"cores"`
	RAMMB     QuotaDetail `json:"ramMB"` // MB
	Instances QuotaDetail `json:"instances"`
}

type CinderQuotaDetail struct {
	Gigabytes QuotaDetail `json:"gigabytes"` // GB
	Volumes   QuotaDetail `json:"volumes"`
	Snapshots QuotaDetail `json:"snapshots"`
}

func (c *Clients) GetNovaQuotaDetail(ctx context.Context, projectID string) (*NovaQuotaDetail, error) {
	q, err := novaqs.GetDetail(ctx, c.ComputeV2, projectID).Extract()
	if err != nil {
		return nil, fmt.Errorf("nova get quota detail: %w", err)
	}
	return &NovaQuotaDetail{
		Cores:     QuotaDetail{Limit: q.Cores.Limit, InUse: q.Cores.InUse},
		RAMMB:     QuotaDetail{Limit: q.RAM.Limit, InUse: q.RAM.InUse},
		Instances: QuotaDetail{Limit: q.Instances.Limit, InUse: q.Instances.InUse},
	}, nil
}

func (c *Clients) GetCinderQuotaDetail(ctx context.Context, targetProjectID string) (*CinderQuotaDetail, error) {
	q, err := cqs.GetUsage(ctx, c.BlockStorageV3, targetProjectID).Extract()
	if err != nil {
		return nil, fmt.Errorf("cinder get quota detail: %w", err)
	}
	return &CinderQuotaDetail{
		Gigabytes: QuotaDetail{Limit: q.Gigabytes.Limit, InUse: q.Gigabytes.InUse},
		Volumes:   QuotaDetail{Limit: q.Volumes.Limit, InUse: q.Volumes.InUse},
		Snapshots: QuotaDetail{Limit: q.Snapshots.Limit, InUse: q.Snapshots.InUse},
	}, nil
}

```

- **Trouble Shooting: nova service type error**
    
    **(6) Trouble shooting** ğŸ”¥
    
    **ì„œë¹„ìŠ¤ íƒ€ì…**
    
    - ê° ì„œë¹„ìŠ¤ëŠ” Keystoneì— **Service ê°ì²´**ë¡œ ë“±ë¡ë˜ê³ , ê·¸ ì•ˆì— `id`, `name`, `type` ì´ ìˆë‹¤
    - `type`ì€ Keystone ì¹´íƒˆë¡œê·¸ ì•ˆì—ì„œ ì„œë¹„ìŠ¤(ê°ì²´)ë¥¼ ì‹ë³„í•˜ëŠ” ë¶„ë¥˜ í‚¤ì˜ ì—­í• ì„ í•œë‹¤.
        - Nova â†’ `compute`
        - Glance â†’ `image`
        - Keystone â†’ `identity`
        - Cinder â†’ `block-storage` í˜¹ì€ `volumev3`
    
    **ì—ëŸ¬ ë©”ì‹œì§€** 
    
    ```json
    âœ  server git:(main) âœ— go run .
    2025/08/27 17:06:48 new blockstorage v3: No suitable endpoint could be found in the service catalog.
    exit status 1
    ```
    
    **ì—ëŸ¬ ì›ì¸** 
    
    ![provider log]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%205.png)
    
    provider log
    
    - providerë¥¼ í™•ì¸í•´ë³´ë©´, cinderì˜ typeì´ `block-storage`ì¸ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.(DevStack ê¶Œì¥ íƒ€ì…)
    - cinder ì„œë¹„ìŠ¤ì˜ type
        - ì‹¤ì œ ì¹´íƒˆë¡œê·¸ â†’ block-storage
        - gophercloud ê¸°ë³¸ â†’ volumev3
    
    **í•´ê²°ë°©ë²•**
    
    cinder ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ìˆë„ë¡ endpoint ë‚´ë¶€ typeì„ ë³€ê²½í•œë‹¤. 
    
    ```go
    block, err := openstack.NewBlockStorageV3(provider, gophercloud.EndpointOpts{
        Region:       cfg.RegionName,
        Type:         "block-storage",                // ì¹´íƒˆë¡œê·¸ì— ìˆëŠ” type ê³¼ ë§ì¶¤
        Name:         "cinder",                       // (ì„ íƒ) name ì¼ì¹˜ì‹œì¼œ ë§¤ì¹­ ë” í™•ì‹¤
        Availability: gophercloud.AvailabilityPublic, // public endpoint ì‚¬ìš©
    })
    ```
    

**(6) ì‹¤í–‰ í™•ì¸**

```bash
# projectId í™•ì¸
 curl -sS "http://localhost:8080/auth/check" | jq -r  '.project.id'
 
# projectIdëŠ” ë³€ê²½
curl -sS "http://localhost:8080/quota/current?projectId=144ba567a5db4334bce43a8c3b54f710" | jq .
```

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%206.png)

ê° cinder, novaì˜ quota ê°’ì„ ì¡°íšŒ í•  ìˆ˜ ìˆë‹¤. 

- Nova: `ramMB` â†’ MB
- Cinder: `gigabytes` â†’ GB

---

### 4-3. ì¿¼í„° ì ìš©

**(0) ì‘ì—… ë°°ê²½** 

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%207.png)

keystoneì—ì„œ providerë¥¼ ë°œê¸‰ë°›ì•„, novaì™€ cinder service clientë¥¼ ìƒì„±í•˜ì˜€ë‹¤. ê° service clientë¡œ quota ì¡°íšŒ ë©”ì†Œë“œ (GetDetail, GetUsage)ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒê¹Œì§€ êµ¬í˜„ëœ ê²ƒì´ë‹¤.

![í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ êµ¬ì¡°]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%208.png)

í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ êµ¬ì¡°

**(1) ì¿¼í„° ì ìš© Request**

```
// types.go
package api

type ApplyQuotaRequest struct {
	ProjectID string `json:"projectId"`

	Nova *struct {
		Cores     *int `json:"cores"`
		RAMMB     *int `json:"ramMB"`
		Instances *int `json:"instances"`
	} `json:"nova,omitempty"`

	Cinder *struct {
		Volumes   *int `json:"volumes"`
		Snapshots *int `json:"snapshots"`
		Gigabytes *int `json:"gigabytes"`
	} `json:"cinder,omitempty"`
}

```

**(2) Handler ìƒì„±**

```go
// quotas_apply_handler.go
package http

import (
	"encoding/json"
	"net/http"

	"example.com/quotaapi/internal/api"
	"example.com/quotaapi/internal/openstack"
)

type QuotaApplyServer struct {
	OS *openstack.Clients
}

func (s *QuotaApplyServer) QuotaApply(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req api.ApplyQuotaRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "invalid JSON body", http.StatusBadRequest)
		return
	}
	if req.ProjectID == "" {
		http.Error(w, "missing projectId", http.StatusBadRequest)
		return
	}

	// 1) Nova ì ìš© (ì¡´ì¬í•˜ëŠ” í•­ëª©ë§Œ)
	if req.Nova != nil {
		if req.Nova.Cores == nil && req.Nova.RAMMB == nil && req.Nova.Instances == nil {
			// ì•„ë¬´ í•„ë“œë„ ì—†ìœ¼ë©´ ìŠ¤í‚µ
		} else {
			if err := s.OS.ApplyNovaQuota(ctx, req.ProjectID, req.Nova.Cores, req.Nova.RAMMB, req.Nova.Instances); err != nil {
				http.Error(w, err.Error(), http.StatusBadGateway)
				return
			}
		}
	}

	// 2) Cinder ì ìš©
	if req.Cinder != nil {
		if req.Cinder.Volumes == nil && req.Cinder.Snapshots == nil && req.Cinder.Gigabytes == nil {
			// ì•„ë¬´ê²ƒë„ ì—†ìœ¼ë©´ ìŠ¤í‚µ
		} else {
			if err := s.OS.ApplyCinderQuota(ctx, req.ProjectID, req.Cinder.Volumes, req.Cinder.Snapshots, req.Cinder.Gigabytes); err != nil {
				http.Error(w, err.Error(), http.StatusBadGateway)
				return
			}
		}
	}

	// 3) ì ìš© í›„ ìµœì‹  ìƒíƒœë¥¼ ì‘ë‹µìœ¼ë¡œ ëŒë ¤ì£¼ë©´ UXê°€ ì¢‹ìŒ
	nova, _ := s.OS.GetNovaQuotaDetail(ctx, req.ProjectID)
	cinder, _ := s.OS.GetCinderQuotaDetail(ctx, req.ProjectID)

	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	_ = json.NewEncoder(w).Encode(map[string]any{
		"projectId": req.ProjectID,
		"nova":      nova,
		"cinder":    cinder,
		"status":    "applied",
	})
}

```

```go
package main
// main.goì— ì¶”ê°€

	srv := &httph.QuotaApplyServer{OS: osc}
	http.HandleFunc("/quota/apply", srv.QuotaApply)

```

**(3) quotas_apply.go**

```go
//quotas_apply.go
package openstack

import (
	"context"
	"fmt"

	cqs "github.com/gophercloud/gophercloud/v2/openstack/blockstorage/v3/quotasets"
	novaqs "github.com/gophercloud/gophercloud/v2/openstack/compute/v2/quotasets"
)

func (c *Clients) ApplyNovaQuota(ctx context.Context, projectID string, cores, ramMB, instances *int) error {
	opts := novaqs.UpdateOpts{
		Cores:     cores,
		RAM:       ramMB,
		Instances: instances,
	}
	_, err := novaqs.Update(ctx, c.ComputeV2, projectID, opts).Extract()
	if err != nil {
		return fmt.Errorf("nova quota update: %w", err)
	}
	return nil
}

func (c *Clients) ApplyCinderQuota(ctx context.Context, projectID string, volumes, snapshots, gigabytes *int) error {
	opts := cqs.UpdateOpts{
		Volumes:   volumes,
		Snapshots: snapshots,
		Gigabytes: gigabytes,
	}

	_, err := cqs.Update(ctx, c.BlockStorageV3, projectID, opts).Extract()
	if err != nil {
		return fmt.Errorf("cinder quota update: %w", err)
	}
	return nil
}

```

**(4) ì‹¤í–‰ í™•ì¸** 

```bash
curl -sS -X POST http://localhost:8080/quota/apply \
  -H 'Content-Type: application/json' \
  -d '{
    "projectId":"144ba567a5db4334bce43a8c3b54f710",
    "nova":   {"cores": 20, "ramMB": 65536, "instances": 20},
    "cinder": {"volumes": 50, "snapshots": 20, "gigabytes": 1000}
  }' | jq .
```

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%209.png)

---

### 4-4. í”„ë¡œíŒŒì¼ ê¸°ë°˜ ì¿¼í„° ì„¤ì •

- ì•ì„œ 3-4ì—ì„œ ì§„í–‰í•œëŒ€ë¡œ, `2ê°€ì§€ í”„ë¡œíŒŒì¼(basic, lab)`ì„ ì„ íƒí•´ quotaë¥¼ ì„¤ì •
- dryRun ì˜µì…˜ì´ ì¡´ì¬ â†’ `dryRun=true`ë©´ ì‹¤ì œ ì¿¼í„° ë³€ê²½ ì—†ì´ ì ìš© ê³„íšë§Œ ì‹œë®¬ë ˆì´ì…˜í•˜ì—¬, ë³€ê²½ ì‚¬í•­ì„ ë¯¸ë¦¬ í™•ì¸

> `/quota/applyProfile` ìš”ì²­ í”Œë¡œìš°

1) ë©”ì„œë“œ/ë°”ë””/í•„ìˆ˜ í•„ë“œ(projectId, profile) ê²€ì¦
2) í”„ë¡œíŒŒì¼ ì¡°íšŒ
3) í˜„ì¬ ì¿¼í„° ì¡°íšŒ(Nova/Cinder)
4) includeDiff=trueë©´ ê³„íšê³¼ í˜„ì¬ì˜ ì°¨ì´ ê³„ì‚°
5) dryRun=falseë©´ ê³„íšëŒ€ë¡œ Nova/Cinder ì¿¼í„° ì ìš© í›„ ìµœì‹  ìƒíƒœ ì¬ì¡°íšŒ
> 

**(1) handler ìƒì„±**

```go
package http

import (
	"encoding/json"
	"net/http"
	"strings"

	"example.com/quotaapi/internal/openstack"
)

// plan: í”„ë¡œíŒŒì¼ì´ ì§€ì •í•˜ëŠ” ëª©í‘œ ì¿¼í„° ê°’ ì§‘í•©
// - Nova: Cores, RAMMB, Instances
// - Cinder: Gigabytes, Volumes, Snapshots
// ì‹¤ì œ ì ìš©ì€ ìš”ì²­(dryRun=false)ì¼ ë•Œ ìˆ˜í–‰ë¨
type plan struct {
	Cores     int `json:"cores"`
	RAMMB     int `json:"ramMB"`
	Instances int `json:"instances"`
	Gigabytes int `json:"gigabytes"`
	Volumes   int `json:"volumes"`
	Snapshots int `json:"snapshots"`
}

// profiles: ì‚¬ì „ì— ì •ì˜ëœ í”„ë¡œíŒŒì¼ ëª©ë¡
// - ì‚¬ìš© ì˜ˆ: profile=basic | lab
// - í•„ìš”í•œ ê²½ìš° í–¥í›„ ì„¤ì • íŒŒì¼/DBë¡œ ë¶„ë¦¬ ê°€ëŠ¥
var profiles = map[string]plan{
	"basic": {Cores: 8, RAMMB: 16384, Instances: 10, Gigabytes: 100, Volumes: 10, Snapshots: 10},
	"lab":   {Cores: 16, RAMMB: 32768, Instances: 20, Gigabytes: 200, Volumes: 20, Snapshots: 20},
}

// applyProfileReq: í”„ë¡œíŒŒì¼ ê¸°ë°˜ ì¿¼í„° ì ìš© ìš”ì²­ ë°”ë””
// - dryRun=true  â†’ ì ìš©í•˜ì§€ ì•Šê³  ê³„íš/ì°¨ì´ë§Œ ë°˜í™˜
// - includeDiff â†’ í˜„ì¬ ì¿¼í„°ì™€ì˜ ì°¨ì´ê°’(diff) í¬í•¨ ì—¬ë¶€
type applyProfileReq struct {
	ProjectID   string `json:"projectId"`
	Profile     string `json:"profile"`
	DryRun      bool   `json:"dryRun"`
	IncludeDiff bool   `json:"includeDiff"`
}

// ApplyProfileServer: OpenStack í´ë¼ì´ì–¸íŠ¸ë¥¼ ì£¼ì…ë°›ì•„ ë™ì‘í•˜ëŠ” í•¸ë“¤ëŸ¬ ì„œë²„
type ApplyProfileServer struct {
	OS *openstack.Clients
}

// NewApplyProfileHandler: POST /quota/applyProfile í•¸ë“¤ëŸ¬ ìƒì„±
// - ìš”ì²­ì„ ê²€ì¦í•˜ê³  í”„ë¡œíŒŒì¼ì„ í™•ì¸í•œ ë’¤
// - í˜„ì¬ ì¿¼í„° ì¡°íšŒ, í•„ìš” ì‹œ diff ê³„ì‚°, dryRun=falseë©´ ì‹¤ì œ ì ìš©
func NewApplyProfileHandler(os *openstack.Clients) http.HandlerFunc {
	s := &ApplyProfileServer{OS: os}
	return s.Handle
}

// Handle: /quota/applyProfile ì²˜ë¦¬ ì—”ë“œí¬ì¸íŠ¸
// ìš”ì²­ í”Œë¡œìš°
// 1) ë©”ì„œë“œ/ë°”ë””/í•„ìˆ˜ í•„ë“œ(projectId, profile) ê²€ì¦
// 2) í”„ë¡œíŒŒì¼ ì¡°íšŒ
// 3) í˜„ì¬ ì¿¼í„° ì¡°íšŒ(Nova/Cinder)
// 4) includeDiff=trueë©´ ê³„íšê³¼ í˜„ì¬ì˜ ì°¨ì´ ê³„ì‚°
// 5) dryRun=falseë©´ ê³„íšëŒ€ë¡œ Nova/Cinder ì¿¼í„° ì ìš© í›„ ìµœì‹  ìƒíƒœ ì¬ì¡°íšŒ
func (s *ApplyProfileServer) Handle(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		WriteJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "POST only"})
		return
	}

	var req applyProfileReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		WriteJSON(w, http.StatusBadRequest, map[string]string{"error": "bad json: " + err.Error()})
		return
	}

	if strings.TrimSpace(req.ProjectID) == "" {
		WriteJSON(w, http.StatusBadRequest, map[string]string{"error": "projectId is required"})
		return
	}

	p, ok := profiles[strings.ToLower(req.Profile)]
	if !ok {
		WriteJSON(w, http.StatusBadRequest, map[string]string{"error": "unknown profile (use 'basic' or 'lab')"})
		return
	}

	ctx := r.Context()

	// í˜„ì¬ ì¿¼í„° ì¡°íšŒ
	novaCurr, nErr := s.OS.GetNovaQuotaDetail(ctx, req.ProjectID)
	cinderCurr, cErr := s.OS.GetCinderQuotaDetail(ctx, req.ProjectID)
	if nErr != nil || cErr != nil {
		WriteJSON(w, http.StatusBadGateway, map[string]any{
			"error":  "failed to read current quotas",
			"nova":   errString(nErr),
			"cinder": errString(cErr),
		})
		return
	}

	// ê¸°ë³¸ ì‘ë‹µ(ê³„íš/í˜„ì¬ ìƒíƒœ)
	resp := map[string]any{
		"projectId": req.ProjectID,
		"profile":   strings.ToLower(req.Profile),
		"plan":      p,
		"applied":   false,
		"dryRun":    req.DryRun,
		"current": map[string]any{
			"nova": map[string]any{
				"cores":     novaCurr.Cores,
				"ramMB":     novaCurr.RAMMB,
				"instances": novaCurr.Instances,
			},
			"cinder": map[string]any{
				"gigabytes": cinderCurr.Gigabytes,
				"volumes":   cinderCurr.Volumes,
				"snapshots": cinderCurr.Snapshots,
			},
		},
	}

	// diff í¬í•¨ ìš”ì²­ ì‹œ, ê³„íš(limit)ê³¼ í˜„ì¬(limit)ì˜ ì°¨ì´ë¥¼ ê³„ì‚°
	if req.IncludeDiff {
		resp["diff"] = map[string]any{
			"nova": map[string]int{
				"cores":     p.Cores - novaCurr.Cores.Limit,
				"ramMB":     p.RAMMB - novaCurr.RAMMB.Limit,
				"instances": p.Instances - novaCurr.Instances.Limit,
			},
			"cinder": map[string]int{
				"gigabytes": p.Gigabytes - cinderCurr.Gigabytes.Limit,
				"volumes":   p.Volumes - cinderCurr.Volumes.Limit,
				"snapshots": p.Snapshots - cinderCurr.Snapshots.Limit,
			},
		}
	}

	// ì‹¤ì œ ì ìš©(dryRun=false)
	if !req.DryRun {
		// Nova ì¿¼í„° ì ìš©
		cores, ram, inst := p.Cores, p.RAMMB, p.Instances
		if err := s.OS.ApplyNovaQuota(ctx, req.ProjectID, &cores, &ram, &inst); err != nil {
			WriteJSON(w, http.StatusBadGateway, map[string]string{"error": "nova apply failed: " + err.Error()})
			return
		}

		// Cinder ì¿¼í„° ì ìš©
		vols, snaps, gigs := p.Volumes, p.Snapshots, p.Gigabytes
		if err := s.OS.ApplyCinderQuota(ctx, req.ProjectID, &vols, &snaps, &gigs); err != nil {
			WriteJSON(w, http.StatusBadGateway, map[string]string{"error": "cinder apply failed: " + err.Error()})
			return
		}

		resp["applied"] = true

		// ì ìš© í›„ ìµœì‹  ìƒíƒœ ì¬ì¡°íšŒ
		novaCurr, _ = s.OS.GetNovaQuotaDetail(ctx, req.ProjectID)
		cinderCurr, _ = s.OS.GetCinderQuotaDetail(ctx, req.ProjectID)
		resp["current"] = map[string]any{
			"nova": map[string]any{
				"cores":     novaCurr.Cores,
				"ramMB":     novaCurr.RAMMB,
				"instances": novaCurr.Instances,
			},
			"cinder": map[string]any{
				"gigabytes": cinderCurr.Gigabytes,
				"volumes":   cinderCurr.Volumes,
				"snapshots": cinderCurr.Snapshots,
			},
		}
	}

	WriteJSON(w, http.StatusOK, resp)
}

```

```go
// main.go ì¶”ê°€

http.HandleFunc("/quota/applyProfile", httph.NewApplyProfileHandler(osc))
```

**(2) ì‹¤í–‰ í™•ì¸** 

ì—”ë“œí¬ì¸íŠ¸ ì‹¤í–‰ í™•ì¸ì„ ìœ„í•´, ì´ 4ê°€ì§€ì˜ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•œë‹¤. 

- `basic profile` dryRun í…ŒìŠ¤íŠ¸
- `basic profile` ì ìš© í…ŒìŠ¤íŠ¸
- `lab profile` dryRun í…ŒìŠ¤íŠ¸
- `lab profile` ì ìš© í…ŒìŠ¤íŠ¸

**(2-1) dryRun í…ŒìŠ¤íŠ¸** 

```go
curl -sS -X POST http://localhost:8080/quota/applyProfile \
  -H 'Content-Type: application/json' \
  -d '{"projectId":"144ba567a5db4334bce43a8c3b54f710","profile":"basic","dryRun":true,"includeDiff":true}' | jq .
```

![currentì™€ basic profile quotaì˜ diff ì¶œë ¥]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%2010.png)

currentì™€ basic profile quotaì˜ diff ì¶œë ¥

**(2-2) `basic profile` ì ìš© í…ŒìŠ¤íŠ¸ (dryRun = false)**

```go
curl -sS -X POST http://localhost:8080/quota/applyProfile \
  -H 'Content-Type: application/json' \
  -d '{"projectId":"144ba567a5db4334bce43a8c3b54f710","profile":"basic","dryRun":false,"includeDiff":true}' | jq .
```

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%2011.png)

**(2-3) `lab profile` dryRun í…ŒìŠ¤íŠ¸**

```go
url -sS -X POST http://localhost:8080/quota/applyProfile \
  -H 'Content-Type: application/json' \
  -d '{"projectId":"144ba567a5db4334bce43a8c3b54f710","profile":"lab","dryRun":true,"includeDiff":true}' | jq .
```

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%2012.png)

(2-4) `lab profile` ì ìš© í…ŒìŠ¤íŠ¸

![image.png]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/image%2013.png)

## 5. ê²°ë¡ 

### 5-1. êµ¬í˜„ ë‚´ìš© ì •ë¦¬

- ê¸°ë³¸ í™˜ê²½ ì„¸íŒ…, Keystone ì¸ì¦, í”„ë¡œì íŠ¸ë³„ Quota ì¡°íšŒ/ì„¤ì •ê¹Œì§€ êµ¬í˜„Â·ê²€ì¦ ì™„ë£Œ.
- í”„ë¡œíŒŒì¼ ê¸°ë°˜(dry-run/ì ìš©) í”Œë¡œìš°ë¡œÂ ìš´ì˜Â ì „ ê²€ì¦ê³¼ ì•ˆì „í•œ ë³€ê²½ì´ ê°€ëŠ¥.
- ë‹¤ìŒÂ ë‹¨ê³„ëŠ” ìì›Â ë¼ì´í”„ì‚¬ì´í´(í• ë‹¹/íšŒìˆ˜)ê³¼ ëª¨ë‹ˆí„°ë§ì„ ì¶”ê°€í•˜ëŠ” ê²ƒ.

### **5-2. ì—”ë“œí¬ì¸íŠ¸**

**ì¸ì¦/í—¬ìŠ¤**

- GETÂ /healthz: ì„œë²„Â ìƒíƒœ í™•ì¸
- GETÂ /auth/check:Â X-Auth-Token(ì˜µì…˜) í† í° ì¸íŠ¸ë¡œìŠ¤í™íŠ¸

**ì¿¼í„° ì¡°íšŒ/ì„¤ì •**

- GETÂ /quota/current?projectId=<ID>: Nova/CinderÂ í˜„ì¬ ì¿¼í„° ìƒì„¸ ì¡°íšŒ
- POSTÂ /quota/apply: ê°œë³„ ê°’ ê¸°ë°˜Â ì¿¼í„° ì ìš©
    - ìš”ì²­:Â {Â "projectId": "...", "nova": {...},Â "cinder": {...} }
- POSTÂ /quota/applyProfile: í”„ë¡œíŒŒì¼ ê¸°ë°˜ ê³„íš/ì ìš©
    - ìš”ì²­:Â {Â "projectId":"...",Â "profile":"basic|lab", "dryRun":true|false, "includeDiff":true|false }
    - ë™ì‘: dryRun=trueë©´Â ê³„íš/í˜„ì¬/diffë§Œ, falseë©´Â ì‹¤ì œÂ ì ìš©Â í›„ ìµœì‹  ìƒíƒœÂ ë°˜í™˜

### 5-3. ë‹¤ìŒ ë‹¨ê³„

**ìì› í• ë‹¹(Provisioning)**

- Nova: ì¸ìŠ¤í„´ìŠ¤ ìƒì„±(ì´ë¯¸ì§€/í”Œë ˆì´ë²„/ë„¤íŠ¸ì›Œí¬/í‚¤í˜ì–´), ë¶€íŒ… í›„ ìƒíƒœÂ í™•ì¸
- Cinder: ë³¼ë¥¨ ìƒì„±(í¬ê¸°/íƒ€ì…), ì¸ìŠ¤í„´ìŠ¤ì— ì–´íƒœì¹˜
- ì‚¬ì „ ê²€ì¦: í˜„ì¬ ì¿¼í„°ì™€Â ì‚¬ìš©ëŸ‰Â ì²´í¬ â†’ ë¶€ì¡± ì‹œ 400 ë°˜í™˜
- íƒ€ì„ì•„ì›ƒ/ì¬ì‹œë„/ì•„ì´í…œí¬í„´ì‹œÂ í‚¤ ë„ì…

**ìì› íšŒìˆ˜(Deprovisioning)**

- ì„œë²„Â ì‚­ì œ(ë””íƒœì¹˜â†’ë³¼ë¥¨Â ì‚­ì œÂ ì˜µì…˜), ê³ ì•„Â ë¦¬ì†ŒìŠ¤Â ì •ë¦¬
- ì‹¤íŒ¨ ì‹œ ë³´ìƒÂ íŠ¸ëœì­ì…˜(rollback) ê°€ì´ë“œ

**ëª¨ë‹ˆí„°ë§**

- êµ¬ì¡°í™”Â ë¡œê·¸, ìš”ì²­Â íŠ¸ë ˆì´ìŠ¤ID
- ìƒíƒœ ë©”íŠ¸ë¦­(ì„±ê³µ/ì‹¤íŒ¨ìœ¨, ì§€ì—°ì‹œê°„), ì¿¼í„°/ì‚¬ìš©ëŸ‰Â ëŒ€ì‹œë³´ë“œ
- ê²½ë³´(ì ìš© ì‹¤íŒ¨, ì‚¬ìš©ë¥ Â ì„ê³„ ì´ˆê³¼)

### 5-4. ìë£Œ

- **ê¹ƒí—™ ë ˆí¬ì§€í† ë¦¬**  [https://github.com/windylung/openstack-infra-manager](https://github.com/windylung/openstack-infra-manager)

[í˜„ì¬ ë‹¨ê³„ê¹Œì§€ì˜ Go code file]((4)%20Quota%20%EC%84%A4%EC%A0%95-2%20254e19595aec80dea118ca065c41fb8d/quota-api.zip)

í˜„ì¬ ë‹¨ê³„ê¹Œì§€ì˜ Go code file