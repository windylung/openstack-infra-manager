# (7) 자원 관리: 학기 시작_자원 초기 할당

담당자: 이지수
진행 상태: 완료
프로젝트: 인프라 관리 솔루션 (https://www.notion.so/223e19595aec8024bd98e7341e341b90?pvs=21)
선행 작업: (6) 자원 관리: 설계 (https://www.notion.so/6-25ce19595aec80a98db4f2395a1e8d61?pvs=21)

## 0. 개요

1. 과목/기간/프로파일 등록 (courses)
2. 학생 등록 및 프로젝트 부트스트랩(최초 1회)
3. 수강(활성) 데이터 적재 (enrollments)
4. 리콘실: 학생별 활성 과목을 그룹핑하여 유효쿼터 계산

## 1. 과목 (courses) 등록

### **1-1. 과목 생성**

```bash
curl -s -X POST http://localhost:8080/courses \
  -H "Content-Type: application/json" \
  -d '{
    "course_id": "AI-2025-1",
    "title": "인공지능 기초",
    "department": "컴퓨터공학과",
    "semester": "2025-1",
    "start_at": "2025-03-01",
    "end_at": "2025-06-30",
    "quota_profile": {
      "instances": 2,
      "cores": 4,
      "ramMB": 8192,
      "volumes": 2,
      "gigabytes": 80,
      "ports": 2,
      "floatingIPs": 1
    },
    "defaults": {
      "imageId": "ubuntu-22.04",
      "flavorIds": ["m1.medium"],
      "networkId": "private-network",
      "externalNetworkID": "public-network",
      "securityGroup": "ai-sg",
      "bootFromVolume": true,
      "rootVolumeGB": 40
    }
  }' | jq .
```

![image.png]((7)%20%EC%9E%90%EC%9B%90%20%EA%B4%80%EB%A6%AC%20%ED%95%99%EA%B8%B0%20%EC%8B%9C%EC%9E%91_%EC%9E%90%EC%9B%90%20%EC%B4%88%EA%B8%B0%20%ED%95%A0%EB%8B%B9%2025ce19595aec804291aee87c0f67a888/image.png)

### **1-2. 과목 조회**

```bash
curl -s http://localhost:8080/courses | jq '.[] | {course_id, title, defaults}'  
```

![image.png]((7)%20%EC%9E%90%EC%9B%90%20%EA%B4%80%EB%A6%AC%20%ED%95%99%EA%B8%B0%20%EC%8B%9C%EC%9E%91_%EC%9E%90%EC%9B%90%20%EC%B4%88%EA%B8%B0%20%ED%95%A0%EB%8B%B9%2025ce19595aec804291aee87c0f67a888/image%201.png)

---

## 2. 학생 등록 및 프로젝트 부트스트랩

### **2-1. Handler 생성**

```go
func (h *StudentHandler) createStudent(w http.ResponseWriter, r *http.Request) {
	var req models.StudentCreateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		WriteJSON(w, http.StatusBadRequest, map[string]any{"error": "invalid json: " + err.Error()})
		return
	}

	// 기본 검증
	if req.StudentID == "" || req.Name == "" || req.Email == "" || req.Department == "" {
		WriteJSON(w, http.StatusBadRequest, map[string]any{"error": "missing required fields"})
		return
	}

	student := &models.Student{
		StudentID:         req.StudentID,
		Name:              req.Name,
		Email:             req.Email,
		Department:        req.Department,
		KeystoneProjectID: "", // OpenStack에서 생성될 예정
		KeystoneUserID:    "", // OpenStack에서 생성될 예정
		CreatedAt:         time.Now(),
	}

	// 1. 데이터베이스에 학생 정보 저장
	if err := h.db.CreateStudent(student); err != nil {
		WriteJSON(w, http.StatusInternalServerError, map[string]any{"error": "failed to create student: " + err.Error()})
		return
	}

	// 2. OpenStack에 프로젝트 생성 (백그라운드에서 처리)
	if h.projectMgr != nil {
		go func() {
			ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
			defer cancel()

			if err := h.projectMgr.CreateStudentProject(ctx, student); err != nil {
				fmt.Printf("Warning: Failed to create OpenStack project for student %s: %v\n", student.StudentID, err)
				return
			}

			// 프로젝트 ID 업데이트
			if err := h.db.UpdateStudent(student.StudentID, map[string]interface{}{
				"keystone_project_id": student.KeystoneProjectID,
				"keystone_user_id":    student.KeystoneUserID,
			}); err != nil {
				fmt.Printf("Warning: Failed to update student with project IDs: %v\n", err)
			}
		}()
	}

	WriteJSON(w, http.StatusCreated, student)
}
```

### **2-2. ProjectManager Service**

프로젝트 초기 생성 시, Quota는 default profile을 적용

```json
"basic": {Cores: 8, RAMMB: 16384, Instances: 10, Gigabytes: 100, Volumes: 10, Snapshots: 10, Ports: 10, FloatingIPs: 5},
```

```go
package openstack

import (
	"context"
	"fmt"
	"strings"

	"example.com/quotaapi/internal/models"
	"github.com/gophercloud/gophercloud/v2/openstack/identity/v3/domains"
	"github.com/gophercloud/gophercloud/v2/openstack/identity/v3/projects"
	"github.com/gophercloud/gophercloud/v2/openstack/identity/v3/roles"
	"github.com/gophercloud/gophercloud/v2/openstack/identity/v3/users"
)

// ProjectManager handles OpenStack project operations for students
type ProjectManager struct {
	clients  *Clients
	domainID string // 캐시
}

// NewProjectManager creates a new project manager
func NewProjectManager(clients *Clients) *ProjectManager {
	return &ProjectManager{clients: clients}
}

// ensureDomainID gets and caches the default domain ID
func (pm *ProjectManager) ensureDomainID(ctx context.Context) (string, error) {
	if pm.domainID != "" {
		return pm.domainID, nil
	}

	// Domain 이름이 "Default"라는 가정 (환경에 맞게 변경 가능)
	pages, err := domains.List(pm.clients.Identity, domains.ListOpts{Name: "Default"}).AllPages(ctx)
	if err != nil {
		return "", fmt.Errorf("list domains: %w", err)
	}

	ds, err := domains.ExtractDomains(pages)
	if err != nil || len(ds) == 0 {
		return "", fmt.Errorf("domain 'Default' not found")
	}

	pm.domainID = ds[0].ID
	return pm.domainID, nil
}

// ptrBool helper function
func ptrBool(b bool) *bool {
	return &b
}

// CreateStudentProject creates a complete student environment in OpenStack
func (pm *ProjectManager) CreateStudentProject(ctx context.Context, student *models.Student) error {
	// 1. 프로젝트 생성
	project, err := pm.createProject(ctx, student)
	if err != nil {
		return fmt.Errorf("failed to create project: %w", err)
	}

	// 2. 사용자 생성
	user, err := pm.createUser(ctx, student)
	if err != nil {
		return fmt.Errorf("failed to create user: %w", err)
	}

	// 3. 사용자를 프로젝트에 할당하고 기본 역할 부여
	if err := pm.assignUserToProjectWithRoles(ctx, user.ID, project.ID); err != nil {
		return fmt.Errorf("failed to assign user to project: %w", err)
	}

	// 4. 기본 쿼타 설정 (basic 프로파일)
	if err := pm.setDefaultQuotas(ctx, project.ID); err != nil {
		return fmt.Errorf("failed to set default quotas: %w", err)
	}

	// 5. 학생 정보 업데이트
	student.KeystoneProjectID = project.ID
	student.KeystoneUserID = user.ID

	return nil
}

// createProject creates a new project for a student
func (pm *ProjectManager) createProject(ctx context.Context, student *models.Student) (*projects.Project, error) {
	did, err := pm.ensureDomainID(ctx)
	if err != nil {
		return nil, err
	}

	projectName := fmt.Sprintf("student-%s-project", student.StudentID)
	projectDescription := fmt.Sprintf("Project for student %s (%s)", student.Name, student.StudentID)

	createOpts := projects.CreateOpts{
		Name:        projectName,
		Description: projectDescription,
		DomainID:    did, // 올바른 DomainID 사용
		Enabled:     ptrBool(true),
	}

	project, err := projects.Create(ctx, pm.clients.Identity, createOpts).Extract()
	if err != nil {
		return nil, fmt.Errorf("failed to create project: %w", err)
	}

	fmt.Printf("Created project: %s (ID: %s)\n", projectName, project.ID)
	return project, nil
}

// createUser creates a new user for a student
func (pm *ProjectManager) createUser(ctx context.Context, student *models.Student) (*users.User, error) {
	did, err := pm.ensureDomainID(ctx)
	if err != nil {
		return nil, err
	}

	userName := fmt.Sprintf("student-%s-user", student.StudentID)
	userDescription := fmt.Sprintf("User account for student %s (%s)", student.Name, student.StudentID)

	// 임시 비밀번호 생성 (실제로는 안전한 방법 사용)
	tempPassword := fmt.Sprintf("temp-%s-2025", student.StudentID)

	createOpts := users.CreateOpts{
		Name:        userName,
		Description: userDescription,
		Password:    tempPassword,
		DomainID:    did, // 올바른 DomainID 사용
		Enabled:     ptrBool(true),
	}

	user, err := users.Create(ctx, pm.clients.Identity, createOpts).Extract()
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	fmt.Printf("Created user: %s (ID: %s)\n", userName, user.ID)
	return user, nil
}

// assignUserToProjectWithRoles assigns a user to a project with default roles
func (pm *ProjectManager) assignUserToProjectWithRoles(ctx context.Context, userID, projectID string) error {
	// 기본 역할: member (실제 존재하는 롤)
	role, err := pm.findRoleByName(ctx, "member")
	if err != nil {
		return fmt.Errorf("member role not found: %w", err)
	}

	// 핵심: 실제 롤 부여
	if err := roles.Assign(ctx, pm.clients.Identity, role.ID, roles.AssignOpts{
		UserID:    userID,
		ProjectID: projectID,
	}).ExtractErr(); err != nil {
		return fmt.Errorf("assign role to user on project: %w", err)
	}

	fmt.Printf("Assigned role %s to user %s on project %s\n", role.Name, userID, projectID)
	return nil
}

// findRoleByName finds a role by name
func (pm *ProjectManager) findRoleByName(ctx context.Context, roleName string) (*roles.Role, error) {
	// 역할 목록 조회
	allPages, err := roles.List(pm.clients.Identity, roles.ListOpts{}).AllPages(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list roles: %w", err)
	}

	roleList, err := roles.ExtractRoles(allPages)
	if err != nil {
		return nil, fmt.Errorf("failed to extract roles: %w", err)
	}

	// 이름으로 역할 찾기
	for _, role := range roleList {
		if strings.EqualFold(role.Name, roleName) {
			return &role, nil
		}
	}

	return nil, fmt.Errorf("role %s not found", roleName)
}

func (pm *ProjectManager) DeleteStudentProject(ctx context.Context, student *models.Student) error {
	if student.KeystoneProjectID == "" {
		return fmt.Errorf("no project ID found for student %s", student.StudentID)
	}

	// 1. 프로젝트 삭제 (사용자 할당도 자동으로 제거됨)
	if err := projects.Delete(ctx, pm.clients.Identity, student.KeystoneProjectID).ExtractErr(); err != nil {
		return fmt.Errorf("failed to delete project: %w", err)
	}

	// 2. 사용자 삭제
	if student.KeystoneUserID != "" {
		if err := users.Delete(ctx, pm.clients.Identity, student.KeystoneUserID).ExtractErr(); err != nil {
			return fmt.Errorf("failed to delete user: %w", err)
		}
	}

	fmt.Printf("Deleted project and user for student %s\n", student.StudentID)
	return nil
}

// ListAllProjects lists all projects in OpenStack
func (pm *ProjectManager) ListAllProjects(ctx context.Context) ([]projects.Project, error) {
	// 프로젝트 목록 조회
	allPages, err := projects.List(pm.clients.Identity, projects.ListOpts{}).AllPages(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list projects: %w", err)
	}

	projectList, err := projects.ExtractProjects(allPages)
	if err != nil {
		return nil, fmt.Errorf("failed to extract projects: %w", err)
	}

	return projectList, nil
}

// FindStudentProject finds a project by student ID pattern
func (pm *ProjectManager) FindStudentProject(ctx context.Context, studentID string) (*projects.Project, error) {
	allProjects, err := pm.ListAllProjects(ctx)
	if err != nil {
		return nil, err
	}

	// student-{studentID}-project 패턴으로 검색
	expectedName := fmt.Sprintf("student-%s-project", studentID)

	for _, project := range allProjects {
		if project.Name == expectedName {
			return &project, nil
		}
	}

	return nil, fmt.Errorf("project not found for student %s", studentID)
}

// setDefaultQuotas sets default quotas for a student project using basic profile
func (pm *ProjectManager) setDefaultQuotas(ctx context.Context, projectID string) error {
	// models.Profiles의 basic 프로파일 사용
	basicProfile := models.GetBasicProfile()

	// Nova 쿼타 설정 (basic 프로파일 값)
	cores := basicProfile.Cores
	ramMB := basicProfile.RAMMB
	instances := basicProfile.Instances
	if err := pm.clients.ApplyNovaQuota(ctx, projectID, &cores, &ramMB, &instances); err != nil {
		return fmt.Errorf("failed to set Nova quotas: %w", err)
	}

	// Cinder 쿼타 설정 (basic 프로파일 값)
	volumes := basicProfile.Volumes
	gigabytes := basicProfile.Gigabytes
	snapshots := basicProfile.Snapshots
	if err := pm.clients.ApplyCinderQuota(ctx, projectID, &volumes, &snapshots, &gigabytes); err != nil {
		return fmt.Errorf("failed to set Cinder quotas: %w", err)
	}

	// Neutron 쿼타 설정
	ports := basicProfile.Ports
	floatingIPs := basicProfile.FloatingIPs
	if err := pm.clients.ApplyNeutronQuota(ctx, projectID, &ports, &floatingIPs); err != nil {
		return fmt.Errorf("failed to set Neutron quotas: %w", err)
	}

	fmt.Printf("Set basic profile quotas for project %s: vCPU=%d, RAM=%dMB, Instances=%d, Volumes=%d, Disk=%dGB, Ports=%d, FloatingIPs=%d\n",
		projectID, cores, ramMB, instances, volumes, gigabytes, ports, floatingIPs)
	return nil
}

```

### **2-3. 실행 확인**

- /openstack/projects API 구현
    
    초기 학생 생성 시, 프로젝트가 openstack 내에 생성되었는지 확인하기 위함이다.
    
    ```go
    // OpenStack 프로젝트 정보 조회 엔드포인트
    	http.HandleFunc("/openstack/projects", studentHandler.ListOpenStackProjects)
    	http.HandleFunc("/openstack/projects/", studentHandler.FindStudentProject)
    ```
    
    ```
    // listOpenStackProjects lists all OpenStack projects
    func (h *StudentHandler) ListOpenStackProjects(w http.ResponseWriter, r *http.Request) {
    	if h.projectMgr == nil {
    		WriteJSON(w, http.StatusServiceUnavailable, map[string]any{"error": "OpenStack not available"})
    		return
    	}
    
    	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    	defer cancel()
    
    	projects, err := h.projectMgr.ListAllProjects(ctx)
    	if err != nil {
    		WriteJSON(w, http.StatusInternalServerError, map[string]any{"error": "failed to list projects: " + err.Error()})
    		return
    	}
    
    	WriteJSON(w, http.StatusOK, map[string]any{
    		"projects": projects,
    		"count":    len(projects),
    	})
    }
    
    // findStudentProject finds a specific student's project in OpenStack
    func (h *StudentHandler) FindStudentProject(w http.ResponseWriter, r *http.Request) {
    	if h.projectMgr == nil {
    		WriteJSON(w, http.StatusServiceUnavailable, map[string]any{"error": "OpenStack not available"})
    		return
    	}
    
    	// URL에서 student_id 추출: /openstack/projects/{student_id}
    	pathParts := strings.Split(r.URL.Path, "/")
    	if len(pathParts) < 4 {
    		WriteJSON(w, http.StatusBadRequest, map[string]any{"error": "invalid path"})
    		return
    	}
    	studentID := pathParts[3]
    
    	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    	defer cancel()
    
    	project, err := h.projectMgr.FindStudentProject(ctx, studentID)
    	if err != nil {
    		WriteJSON(w, http.StatusNotFound, map[string]any{"error": "project not found: " + err.Error()})
    		return
    	}
    ```
    

```bash
# 학생 생성
curl -s -X POST http://localhost:8080/students \
  -H "Content-Type: application/json" \
  -d '{
    "student_id": "32210003",
    "name": "이지수",
    "email": "jisoo@dankook.ac.kr",
    "department": "소프트웨어학과"
  }' | jq .
  
  
# 학생 조회
curl -s -X GET http://localhost:8080/students | jq .
curl -s -X GET http://localhost:8080/students/32210003 | jq .

# 프로젝트 조회
curl -s -X GET http://localhost:8080/openstack/projects | jq .
curl -s -X GET http://localhost:8080/openstack/projects/32210003 | jq .

# 프로젝트 쿼터 설정 조회 (초기 생성 시 default profile 할당)
curl -s "http://localhost:8080/quota/current?projectId=98077908079746cab05e896ebf54258f" | jq .
```

```go
// vm 내부에서 
ubuntu@ubuntu:~$ openstack project list
```

![image.png]((7)%20%EC%9E%90%EC%9B%90%20%EA%B4%80%EB%A6%AC%20%ED%95%99%EA%B8%B0%20%EC%8B%9C%EC%9E%91_%EC%9E%90%EC%9B%90%20%EC%B4%88%EA%B8%B0%20%ED%95%A0%EB%8B%B9%2025ce19595aec804291aee87c0f67a888/image%202.png)

![image.png]((7)%20%EC%9E%90%EC%9B%90%20%EA%B4%80%EB%A6%AC%20%ED%95%99%EA%B8%B0%20%EC%8B%9C%EC%9E%91_%EC%9E%90%EC%9B%90%20%EC%B4%88%EA%B8%B0%20%ED%95%A0%EB%8B%B9%2025ce19595aec804291aee87c0f67a888/b87a5727-b70e-4d06-a7fa-d3ae7a7a403f.png)

![image.png]((7)%20%EC%9E%90%EC%9B%90%20%EA%B4%80%EB%A6%AC%20%ED%95%99%EA%B8%B0%20%EC%8B%9C%EC%9E%91_%EC%9E%90%EC%9B%90%20%EC%B4%88%EA%B8%B0%20%ED%95%A0%EB%8B%B9%2025ce19595aec804291aee87c0f67a888/image%203.png)

![image.png]((7)%20%EC%9E%90%EC%9B%90%20%EA%B4%80%EB%A6%AC%20%ED%95%99%EA%B8%B0%20%EC%8B%9C%EC%9E%91_%EC%9E%90%EC%9B%90%20%EC%B4%88%EA%B8%B0%20%ED%95%A0%EB%8B%B9%2025ce19595aec804291aee87c0f67a888/image%204.png)

---

## 3. 수강 데이터 적재

현재 학생과 수업 데이터는 DB에 생성되었으므로 → 두 테이블을 연결하는 수강 데이터를 추가한다. 

### 3-1. 구현 코드

```go
func (h *StudentHandler) enrollStudent(w http.ResponseWriter, r *http.Request) {
	pathParts := strings.Split(r.URL.Path, "/")
	if len(pathParts) < 4 {
		WriteJSON(w, http.StatusBadRequest, map[string]any{"error": "invalid path"})
		return
	}

	studentID := pathParts[2]
	var req models.EnrollmentCreateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		WriteJSON(w, http.StatusBadRequest, map[string]any{"error": "invalid json: " + err.Error()})
		return
	}

	// 과목 정보 조회하여 기간 가져오기
	course, err := h.db.GetCourse(req.CourseID)
	if err != nil {
		WriteJSON(w, http.StatusBadRequest, map[string]any{"error": "course not found: " + err.Error()})
		return
	}

	enrollment := &models.Enrollment{
		StudentID: studentID,
		CourseID:  req.CourseID,
		Status:    req.Status,
		StartAt:   course.StartAt,  // 과목의 시작일 사용
		EndAt:     course.EndAt,    // 과목의 종료일 사용
	}

	if err := h.db.EnrollStudent(enrollment); err != nil {
		WriteJSON(w, http.StatusInternalServerError, map[string]any{"error": "failed to enroll: " + err.Error()})
		return
	}

	WriteJSON(w, http.StatusCreated, enrollment)
}
```

### 3-2. 실행 확인

```json
curl -s -X POST "http://localhost:8080/students/32210003/enroll" \
  -H "Content-Type: application/json" \
  -d '{"course_id": "CC-2025-2", "status": "active"}' | jq .
```

![image.png]((7)%20%EC%9E%90%EC%9B%90%20%EA%B4%80%EB%A6%AC%20%ED%95%99%EA%B8%B0%20%EC%8B%9C%EC%9E%91_%EC%9E%90%EC%9B%90%20%EC%B4%88%EA%B8%B0%20%ED%95%A0%EB%8B%B9%2025ce19595aec804291aee87c0f67a888/image%205.png)

![image.png]((7)%20%EC%9E%90%EC%9B%90%20%EA%B4%80%EB%A6%AC%20%ED%95%99%EA%B8%B0%20%EC%8B%9C%EC%9E%91_%EC%9E%90%EC%9B%90%20%EC%B4%88%EA%B8%B0%20%ED%95%A0%EB%8B%B9%2025ce19595aec804291aee87c0f67a888/image%206.png)

## 4. 리콘실: 쿼터 재설정

학생별 quota를 계산하고 OpenStack에 적용한다. 

수강 등록 시 **즉시 쿼타 재설정되도록** 구현 (추후 특정 시간에 대량 리콘실 구현 필요)

**(1) 구현 코드** 

```go
	// 4-5) 리콘실 서비스 및 핸들러
	reconciliationService := services.NewQuotaReconciliationService(db, projectMgr)
	reconciliationHandler := httph.NewReconciliationHandler(reconciliationService)
	http.HandleFunc("/reconciliation/", reconciliationHandler.ServeHTTP)
```

```go
package services

import (
	"context"
	"fmt"
	"log"

	"example.com/quotaapi/internal/database"
	"example.com/quotaapi/internal/models"
	"example.com/quotaapi/internal/openstack"
)

// QuotaReconciliationService handles bulk quota reconciliation
type QuotaReconciliationService struct {
	db         *database.Database
	projectMgr *openstack.ProjectManager
}

// NewQuotaReconciliationService creates a new reconciliation service
func NewQuotaReconciliationService(db *database.Database, projectMgr *openstack.ProjectManager) *QuotaReconciliationService {
	return &QuotaReconciliationService{
		db:         db,
		projectMgr: projectMgr,
	}
}

// StudentQuotaSummary represents a student's quota summary
type StudentQuotaSummary struct {
	StudentID      string              `json:"student_id"`
	StudentName    string              `json:"student_name"`
	BaselineQuota  models.QuotaProfile `json:"baseline_quota"`
	ActiveCourses  []models.Course     `json:"active_courses"`
	EffectiveQuota models.QuotaProfile `json:"effective_quota"`
	AppliedQuota   models.QuotaProfile `json:"applied_quota,omitempty"`
	Status         string              `json:"status"` // success, failed, pending
	ErrorMessage   string              `json:"error_message,omitempty"`
}

// BulkReconciliationResult represents the result of bulk reconciliation
type BulkReconciliationResult struct {
	TotalStudents  int                   `json:"total_students"`
	SuccessCount   int                   `json:"success_count"`
	FailedCount    int                   `json:"failed_count"`
	PendingCount   int                   `json:"pending_count"`
	StudentResults []StudentQuotaSummary `json:"student_results"`
	Summary        string                `json:"summary"`
}

// RunBulkReconciliation runs bulk quota reconciliation for all students
func (s *QuotaReconciliationService) RunBulkReconciliation(ctx context.Context) (*BulkReconciliationResult, error) {
	log.Println("Starting bulk quota reconciliation...")

	// 1. 모든 학생 조회
	students, err := s.db.GetAllStudents()
	if err != nil {
		return nil, fmt.Errorf("failed to get students: %w", err)
	}

	result := &BulkReconciliationResult{
		TotalStudents:  len(students),
		StudentResults: make([]StudentQuotaSummary, 0, len(students)),
	}

	// 2. 각 학생별로 리콘실 실행
	for _, student := range students {
		studentResult := s.reconcileStudentQuota(ctx, student)
		result.StudentResults = append(result.StudentResults, studentResult)

		// 통계 업데이트
		switch studentResult.Status {
		case "success":
			result.SuccessCount++
		case "failed":
			result.FailedCount++
		case "pending":
			result.PendingCount++
		}
	}

	// 3. 결과 요약 생성
	result.Summary = fmt.Sprintf("Reconciliation completed: %d success, %d failed, %d pending",
		result.SuccessCount, result.FailedCount, result.PendingCount)

	log.Printf("Bulk reconciliation completed: %s", result.Summary)
	return result, nil
}

// ReconcileQuota reconciles quota for a single student after enrollment changes
func (s *QuotaReconciliationService) ReconcileQuota(ctx context.Context, studentID, courseID string) error {
	// 학생 정보 조회
	student, err := s.db.GetStudent(studentID)
	if err != nil {
		return fmt.Errorf("failed to get student %s: %w", studentID, err)
	}

	// 개별 학생 리콘실 실행
	summary := s.reconcileStudentQuota(ctx, student)

	if summary.Status == "success" {
		log.Printf("Successfully reconciled quota for student %s after enrollment in course %s", studentID, courseID)
	} else {
		log.Printf("Failed to reconcile quota for student %s: %s", studentID, summary.ErrorMessage)
	}

	return nil
}

// reconcileStudentQuota reconciles quota for a single student
func (s *QuotaReconciliationService) reconcileStudentQuota(ctx context.Context, student *models.Student) StudentQuotaSummary {
	summary := StudentQuotaSummary{
		StudentID:     student.StudentID,
		StudentName:   student.Name,
		BaselineQuota: models.GetBasicProfile(), // 기본 프로파일
		Status:        "pending",
	}

	// 1. 학생의 활성 수강 과목 조회
	enrollments, err := s.db.GetStudentEnrollments(student.StudentID)
	if err != nil {
		summary.Status = "failed"
		summary.ErrorMessage = fmt.Sprintf("failed to get enrollments: %v", err)
		return summary
	}

	// 2. 활성 과목만 필터링
	var activeCourses []models.Course
	for _, enrollment := range enrollments {
		if enrollment.Status == "active" {
			course, err := s.db.GetCourse(enrollment.CourseID)
			if err != nil {
				log.Printf("Warning: failed to get course %s: %v", enrollment.CourseID, err)
				continue
			}
			activeCourses = append(activeCourses, *course)
		}
	}
	summary.ActiveCourses = activeCourses

	// 3. 유효 쿼터 계산: baseline + Σ(활성 과목 쿼타)
	effectiveQuota := s.calculateEffectiveQuota(summary.BaselineQuota, activeCourses)
	summary.EffectiveQuota = effectiveQuota

	// 4. OpenStack 프로젝트가 있는 경우 쿼타 적용
	if student.KeystoneProjectID != "" && s.projectMgr != nil {
		if err := s.applyQuotaToOpenStack(ctx, student.KeystoneProjectID, effectiveQuota); err != nil {
			summary.Status = "failed"
			summary.ErrorMessage = fmt.Sprintf("failed to apply quota: %v", err)
			return summary
		}
		summary.AppliedQuota = effectiveQuota
		summary.Status = "success"
	} else {
		summary.Status = "pending"
		summary.ErrorMessage = "no OpenStack project or project manager"
	}

	return summary
}

// calculateEffectiveQuota calculates effective quota by adding course quotas to baseline
func (s *QuotaReconciliationService) calculateEffectiveQuota(baseline models.QuotaProfile, courses []models.Course) models.QuotaProfile {
	effective := baseline // baseline 복사

	// 각 활성 과목의 쿼타를 baseline에 추가
	for _, course := range courses {
		effective.Instances += course.QuotaProfile.Instances
		effective.Cores += course.QuotaProfile.Cores
		effective.RAMMB += course.QuotaProfile.RAMMB
		effective.Volumes += course.QuotaProfile.Volumes
		effective.Gigabytes += course.QuotaProfile.Gigabytes
		effective.Ports += course.QuotaProfile.Ports
		effective.FloatingIPs += course.QuotaProfile.FloatingIPs
		effective.Snapshots += course.QuotaProfile.Snapshots
	}

	return effective
}

// applyQuotaToOpenStack applies the calculated quota to OpenStack project
func (s *QuotaReconciliationService) applyQuotaToOpenStack(ctx context.Context, projectID string, quota models.QuotaProfile) error {
	// Nova 쿼타 적용
	cores := quota.Cores
	ramMB := quota.RAMMB
	instances := quota.Instances
	if err := s.projectMgr.GetClients().ApplyNovaQuota(ctx, projectID, &cores, &ramMB, &instances); err != nil {
		return fmt.Errorf("failed to apply Nova quota: %w", err)
	}

	// Cinder 쿼타 적용
	volumes := quota.Volumes
	gigabytes := quota.Gigabytes
	snapshots := quota.Snapshots
	if err := s.projectMgr.GetClients().ApplyCinderQuota(ctx, projectID, &volumes, &snapshots, &gigabytes); err != nil {
		return fmt.Errorf("failed to apply Cinder quota: %w", err)
	}

	// Neutron 쿼타 적용
	ports := quota.Ports
	floatingIPs := quota.FloatingIPs
	if err := s.projectMgr.GetClients().ApplyNeutronQuota(ctx, projectID, &ports, &floatingIPs); err != nil {
		return fmt.Errorf("failed to apply Neutron quota: %w", err)
	}

	log.Printf("Applied quota to project %s: vCPU=%d, RAM=%dMB, Instances=%d, Volumes=%d, Disk=%dGB, Ports=%d, FloatingIPs=%d",
		projectID, cores, ramMB, instances, volumes, gigabytes, ports, floatingIPs)

	return nil
}

```

### 4-2. 실행 확인

아래와 같은 순서로 학생**이 수강 과목에 따라 quota를 배정 받는지 확인을 진행한다.** 

(1) student 등록 후 초기 project quota 확인

(2) course 수강 (enrollment 데이터 생성) 후 변경된 project quota 확인 

(3) 추가 course 수강 (enrollment 데이터 생성) 후 추가된 quota 확인

**(1) student 등록** 

```bash
# student 생성
curl -s -X POST http://localhost:8080/students \  -H "Content-Type: application/json" \      
  -d '{
    "student_id": "32210006",
    "name": "이지수",
    "email": "jisoo@dankook.ac.kr",
    "department": "소프트웨어학과"
  }' | jq .

# 학생 소유 프로젝트 조회
curl -s -X GET http://localhost:8080/openstack/projects/32210006 | jq .

  
# 프로젝트 quota (초기 quota) 조회
curl -s -X GET "http://localhost:8080/quota/current?projectId=a8fee14aff1d4072945d63b483394d9b" | jq .
```

- 실행 결과 (초기 quota)
    
    ```json
    {
      "cinder": {
        "gigabytes": {
          "limit": 100,
          "in_use": 0
        },
        "volumes": {
          "limit": 10,
          "in_use": 0
        },
        "snapshots": {
          "limit": 10,
          "in_use": 0
        }
      },
      "neutron": {
        "port": {
          "limit": 10,
          "in_use": 0
        },
        "floatingIP": {
          "limit": 5,
          "in_use": 0
        }
      },
      "nova": {
        "cores": {
          "limit": 8,
          "in_use": 0
        },
        "ramMB": {
          "limit": 16384,
          "in_use": 0
        },
        "instances": {
          "limit": 10,
          "in_use": 0
        }
      },
      "projectId": "a8fee14aff1d4072945d63b483394d9b"
    ```
    

**(2) course 수강 (enrollment 데이터 생성)** 

```bash
# 과목 (course) 전체 조회
curl -s -X GET http://localhost:8080/courses | jq .

# 학생 32210006을 AI 과목에 수강 등록
curl -s -X POST "http://localhost:8080/students/32210006/enroll" \
  -H "Content-Type: application/json" \
  -d '{"course_id": "AI-2025-1", "status": "active"}' | jq .
  
# 수강 후 quota 조회
url -s -X GET "http://localhost:8080/quota/current?projectId=a8fee14aff1d4072945d63b483394d9b" | jq .
```

- 실행 결과 (quota 변경)
    
    ```json
    {
      "cinder": {
        "gigabytes": {
          "limit": 180,
          "in_use": 0
        },
        "volumes": {
          "limit": 12,
          "in_use": 0
        },
        "snapshots": {
          "limit": 10,
          "in_use": 0
        }
      },
      "neutron": {
        "port": {
          "limit": 12,
          "in_use": 0
        },
        "floatingIP": {
          "limit": 6,
          "in_use": 0
        }
      },
      "nova": {
        "cores": {
          "limit": 12,
          "in_use": 0
        },
        "ramMB": {
          "limit": 24576,
          "in_use": 0
        },
        "instances": {
          "limit": 12,
          "in_use": 0
        }
      },
      "projectId": "a8fee14aff1d4072945d63b483394d9b"
    }
    ```
    

**(3) 추가 course 수강 (enrollment 데이터 생성)**

```bash
# 학생 32210006을 CC-2025-2 과목에 수강 등록 
curl -s -X POST "http://localhost:8080/students/32210006/enroll" \
  -H "Content-Type: application/json" \
  -d '{"course_id": "CC-2025-2", "status": "active"}' | jq .
  
    
# 수강 후 quota 조회
url -s -X GET "http://localhost:8080/quota/current?projectId=a8fee14aff1d4072945d63b483394d9b" | jq .
```

- 실행 결과 (quota 추가)
    
    ```json
    {
      "cinder": {
        "gigabytes": {
          "limit": 330,
          "in_use": 0
        },
        "volumes": {
          "limit": 15,
          "in_use": 0
        },
        "snapshots": {
          "limit": 10,
          "in_use": 0
        }
      },
      "neutron": {
        "port": {
          "limit": 15,
          "in_use": 0
        },
        "floatingIP": {
          "limit": 8,
          "in_use": 0
        }
      },
      "nova": {
        "cores": {
          "limit": 18,
          "in_use": 0
        },
        "ramMB": {
          "limit": 36864,
          "in_use": 0
        },
        "instances": {
          "limit": 15,
          "in_use": 0
        }
      },
      "projectId": "a8fee14aff1d4072945d63b483394d9b"
    }
    ```